<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuralWave Dashboard</title>
    <!-- Ignore production warning for local tool -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        gray: {
                            900: '#111827',
                            800: '#1f2937',
                            700: '#374151',
                        },
                        cyan: {
                            500: '#06b6d4',
                            600: '#0891b2',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .glass {
            background: rgba(31, 41, 55, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        /* Hide scrollbar for analysis list */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body class="bg-gray-950 text-gray-100 min-h-screen selection:bg-cyan-500 selection:text-white">

    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        
        <!-- Header -->
        <header class="mb-8 flex justify-between items-center">
            <div>
                <h1 class="text-4xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 to-blue-500">
                    NeuralWave
                </h1>
                <p class="text-gray-400 mt-1">Real-time Verified Model Benchmarking</p>
            </div>
            <div class="flex items-center space-x-6">
                <!-- Tabs -->
                <div class="flex bg-gray-900 p-1 rounded-lg border border-gray-800">
                    <button onclick="showTab('dashboard')" id="tab-dashboard" class="px-4 py-2 rounded-md text-sm font-medium transition-all bg-gray-800 text-cyan-400 shadow">Dashboard</button>
                    <button onclick="showTab('analysis')" id="tab-analysis" class="px-4 py-2 rounded-md text-sm font-medium text-gray-400 hover:text-white transition-all">Analysis</button>
                    <button onclick="showTab('compare')" id="tab-compare" class="px-4 py-2 rounded-md text-sm font-medium text-gray-400 hover:text-white transition-all">Compare</button>
                    <button onclick="showTab('visualize')" id="tab-visualize" class="px-4 py-2 rounded-md text-sm font-medium text-gray-400 hover:text-white transition-all">Visualize 3D</button>
                    <button onclick="showTab('inspect')" id="tab-inspect" class="px-4 py-2 rounded-md text-sm font-medium text-gray-400 hover:text-white transition-all">üîç Inspect</button>
                </div>

                <div class="flex items-center space-x-2 border-l border-gray-800 pl-6">
                    <div id="connStatus" class="h-3 w-3 bg-red-500 rounded-full"></div>
                    <span id="connText" class="text-xs font-mono text-gray-400">DISCONNECTED</span>
                </div>
            </div>
        </header>

        <!-- Progress Bar (Global) -->
        <div id="progressContainer" class="mb-6 hidden">
            <div class="flex justify-between mb-1">
                <span class="text-sm font-medium text-cyan-400 animate-pulse">Processing...</span>
                <span id="progressText" class="text-sm font-medium text-gray-400">0/0</span>
            </div>
            <div class="w-full bg-gray-900 rounded-full h-2.5">
                <div id="progressBar" class="bg-cyan-500 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>

        <!-- VIEW: DASHBOARD -->
        <div id="view-dashboard" class="animate-fade-in">
            <!-- Stats & Actions Grid -->
            <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-10">
                <!-- Stat Card -->
                <div class="glass rounded-xl p-6 relative overflow-hidden group">
                    <div class="absolute -right-6 -top-6 w-24 h-24 bg-cyan-500/10 rounded-full group-hover:bg-cyan-500/20 transition-all"></div>
                    <dt class="text-sm font-medium text-gray-400">Total Models</dt>
                    <dd class="mt-2 text-3xl font-bold text-white" id="totalModels">0</dd>
                </div>
                
                <!-- Actions -->
                <button onclick="sendAction('scan')" class="group relative flex items-center justify-center p-6 rounded-xl bg-gray-900 border border-gray-800 hover:border-cyan-500/50 transition-all hover:shadow-[0_0_20px_rgba(6,182,212,0.15)]">
                    <div class="text-center">
                        <div class="mb-2 mx-auto w-10 h-10 rounded-full bg-cyan-500/10 flex items-center justify-center text-cyan-400 group-hover:scale-110 transition-transform">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                        </div>
                        <span class="font-semibold text-gray-200">1. Scan Models</span>
                        <p class="text-xs text-gray-500 mt-1">Read from HF Cache</p>
                    </div>
                </button>

                <button onclick="sendAction('verify')" class="group relative flex items-center justify-center p-6 rounded-xl bg-gray-900 border border-gray-800 hover:border-purple-500/50 transition-all hover:shadow-[0_0_20px_rgba(168,85,247,0.15)]">
                    <div class="text-center">
                        <div class="mb-2 mx-auto w-10 h-10 rounded-full bg-purple-500/10 flex items-center justify-center text-purple-400 group-hover:scale-110 transition-transform">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        </div>
                        <span class="font-semibold text-gray-200">2. Verify Loop</span>
                        <p class="text-xs text-gray-500 mt-1">Start Background Check</p>
                    </div>
                </button>

                <button onclick="sendAction('benchmark')" class="group relative flex items-center justify-center p-6 rounded-xl bg-gray-900 border border-gray-800 hover:border-green-500/50 transition-all hover:shadow-[0_0_20px_rgba(34,197,94,0.15)]">
                    <div class="text-center">
                        <div class="mb-2 mx-auto w-10 h-10 rounded-full bg-green-500/10 flex items-center justify-center text-green-400 group-hover:scale-110 transition-transform">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        </div>
                        <span class="font-semibold text-gray-200">3. Benchmark</span>
                        <p class="text-xs text-gray-500 mt-1">Start TPS Test</p>
                    </div>
                </button>
            </div>

            <!-- Filters / Status Bar -->
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-lg font-semibold text-gray-300">Model Registry <span id="streamStatus" class="ml-2 text-xs font-mono text-cyan-400 animate-pulse hidden">RECEIVING UPDATES...</span></h2>
                <div class="text-sm space-x-4">
                    <span class="text-gray-500">Selected: <span id="countSelected" class="text-cyan-400 font-bold">0</span></span>
                    <span class="text-gray-500">Loadable: <span id="countLoadable" class="text-gray-300 font-bold">0</span></span>
                    <span class="text-gray-500">Benchmarked: <span id="countBench" class="text-gray-300 font-bold">0</span></span>
                </div>
            </div>

            <!-- Table -->
            <div class="glass rounded-xl overflow-hidden border border-gray-800">
                <div class="overflow-x-auto">
                    <table class="w-full text-left">
                        <thead class="bg-gray-800/50 text-xs uppercase font-semibold text-gray-400">
                            <tr>
                                <th class="px-4 py-4 w-10 text-center">
                                    <input type="checkbox" disabled class="rounded bg-gray-700 border-gray-600">
                                </th>
                                <th class="px-6 py-4">Model Name</th>
                                <th class="px-6 py-4 text-center">Loadable</th>
                                <th class="px-6 py-4 text-center">TPS</th>
                                <th class="px-6 py-4 text-center">Status</th>
                                <th class="px-6 py-4">Output Preview</th>
                                <th class="px-6 py-4 text-right">Last Checked</th>
                            </tr>
                        </thead>
                        <tbody id="modelTableBody" class="divide-y divide-gray-800">
                            <!-- Rows injected via JS -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- VIEW: ANALYSIS -->
        <div id="view-analysis" class="animate-fade-in hidden">
            <div class="flex justify-between items-center mb-6">
                <div>
                    <h2 class="text-2xl font-bold text-white">Deep Layer Analysis</h2>
                    <p class="text-gray-400 text-sm">Inspect layer types and parameter distribution for selected models.</p>
                </div>
                <button onclick="sendAction('analyze')" class="px-6 py-3 bg-cyan-600 hover:bg-cyan-500 text-white rounded-xl font-semibold shadow-lg shadow-cyan-500/20 transition-all flex items-center space-x-2">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"></path></svg>
                    <span>Analyze Selected</span>
                </button>
            </div>

            <div id="analysisGrid" class="grid grid-cols-1 gap-8">
                <!-- Analysis Cards injected here -->
                <div class="text-center py-20 text-gray-500">
                    Select models in the Dashboard and click "Analyze Selected"
                </div>
            </div>
        </div>

        <!-- VIEW: COMPARE -->
        <div id="view-compare" class="animate-fade-in hidden h-[calc(100vh-140px)] flex flex-col">
             <div class="flex justify-between items-center mb-6">
                <div>
                    <h2 class="text-2xl font-bold text-white">Model Comparison</h2>
                    <p class="text-gray-400 text-sm">Compare weights and biases across selected models.</p>
                </div>
                <div class="text-sm text-gray-500">
                    Comparing <span id="compareCount" class="text-cyan-400 font-bold">0</span> models
                </div>
            </div>

            <div class="flex-1 flex overflow-hidden gap-6">
                <!-- Sidebar: Layers -->
                <div class="w-1/3 glass rounded-xl border border-gray-700 flex flex-col">
                    <div class="p-4 border-b border-gray-700 bg-gray-900/50 space-y-3">
                        <button onclick="sendAction('compare')" class="w-full py-2 bg-purple-600 hover:bg-purple-500 text-white rounded-lg font-semibold shadow-lg shadow-purple-500/20 transition-all text-sm flex items-center justify-center space-x-2">
                             <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                            <span>Run Comparison</span>
                        </button>
                        <input type="text" id="layerSearch" placeholder="Search layers..." onkeyup="filterCompareLayers()" class="w-full bg-gray-800 border-gray-700 rounded-lg px-3 py-2 text-sm text-white focus:ring-1 focus:ring-cyan-500 outline-none">
                    </div>
                    <div id="compareLayerList" class="flex-1 overflow-y-auto p-2 space-y-1 no-scrollbar">
                        <div class="text-gray-500 text-center py-10 text-sm">
                            1. Select models in Dashboard<br>
                            2. Click "Run Comparison"<br>
                            3. Select a layer here
                        </div>
                    </div>
                </div>

                <!-- Main: Stats -->
                <div class="w-2/3 glass rounded-xl border border-gray-700 p-6 overflow-y-auto">
                    <div id="compareStatsEmpty" class="h-full flex flex-col items-center justify-center text-gray-500">
                        <svg class="w-12 h-12 mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6l3 1m0 0l-3 9a5.002 5.002 0 006.001 0M6 7l3 9M6 7l6-2m6 2l3-1m-3 1l-3 9a5.002 5.002 0 006.001 0M18 7l3 9m-3-9l-6-2m0-2v2m0 16V5m0 16H9m3 0h3"></path></svg>
                        <span>Select a layer on the left to compare stats</span>
                    </div>
                    <div id="compareStatsContent" class="hidden">
                        <h3 id="compareLayerTitle" class="text-xl font-bold text-white mb-6 font-mono break-all"></h3>
                        <div class="overflow-x-auto">
                            <table class="w-full text-left">
                                <thead class="text-xs uppercase text-gray-500 border-b border-gray-700">
                                    <tr>
                                        <th class="pb-3 pl-2">Model</th>
                                        <th class="pb-3 text-right">Mean</th>
                                        <th class="pb-3 text-right">StdDev</th>
                                        <th class="pb-3 text-right">Min</th>
                                        <th class="pb-3 text-right pr-2">Max</th>
                                    </tr>
                                </thead>
                                <tbody id="compareStatsBody" class="divide-y divide-gray-800">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- VIEW: VISUALIZE (Three.js) -->
        <div id="view-visualize" class="animate-fade-in hidden h-[calc(100vh-140px)] flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <div>
                     <h2 class="text-2xl font-bold text-white">3D Visualization</h2>
                     <p class="text-gray-400 text-sm">Visualize model architecture as specific blocks.</p>
                </div>
                <div class="flex items-center space-x-4">
                    <div class="flex items-center space-x-2 bg-gray-900 rounded-lg p-1 border border-gray-700">
                        <select id="viz-model-select" onchange="onVizModelChange()" class="bg-gray-800 text-white text-xs font-bold py-1 px-3 rounded outline-none border-none min-w-[180px]">
                            <option value="">Select Model...</option>
                        </select>
                        <select id="viz-layer-select" onchange="onVizLayerChange()" class="bg-gray-800 text-white text-xs font-bold py-1 px-3 rounded outline-none border-none min-w-[200px]">
                            <option value="">All Layers</option>
                        </select>
                        <button onclick="startVizGeneration()" class="px-3 py-1 text-xs rounded font-bold bg-cyan-600 text-white hover:bg-cyan-500 transition-all">
                            Generate
                        </button>
                    </div>
                    <!-- LOOM Model Controls -->
                    <div class="flex items-center space-x-2 bg-gray-900 rounded-lg p-1 border border-purple-700/50">
                        <input type="text" id="loom-folder-path" value="./loom/examples/step_example" 
                               placeholder="LOOM folder path" 
                               class="bg-gray-800 text-white text-xs py-1 px-2 rounded outline-none border-none w-[180px] placeholder-gray-500">
                        <button onclick="scanLoomFolder()" class="px-2 py-1 text-xs rounded font-bold bg-purple-600 text-white hover:bg-purple-500 transition-all">
                            Scan
                        </button>
                        <select id="viz-loom-select" onchange="onLoomModelChange()" class="bg-gray-800 text-white text-xs font-bold py-1 px-3 rounded outline-none border-none min-w-[160px]">
                            <option value="">LOOM Models...</option>
                        </select>
                        <button onclick="loadLoomModel()" class="px-3 py-1 text-xs rounded font-bold bg-purple-600 text-white hover:bg-purple-500 transition-all">
                            Load LOOM
                        </button>
                    </div>
                    <!-- Inter-Layer Connections Toggle -->
                    <label class="flex items-center space-x-2 bg-gray-900 rounded-lg px-3 py-1 border border-gray-700 cursor-pointer select-none">
                        <input type="checkbox" id="viz-connections-toggle" onchange="toggleInterLayerConnections()" class="w-4 h-4 rounded bg-gray-800 border-gray-600 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-gray-900 cursor-pointer">
                        <span class="text-xs font-medium text-gray-300">Layer Connections</span>
                    </label>
                </div>
            </div>
            <div id="three-container" class="flex-1 rounded-xl glass overflow-hidden relative border border-gray-700">
                <div id="viz-loading" class="absolute inset-0 flex flex-col items-center justify-center bg-gray-900/90 z-10 hidden">
                    <div class="w-12 h-12 border-4 border-cyan-500 border-t-transparent rounded-full animate-spin mb-4"></div>
                    <span id="viz-loading-text" class="text-cyan-400 font-mono text-lg animate-pulse">Initializing...</span>
                    <div class="w-64 bg-gray-800 rounded-full h-1 mt-4">
                        <div id="viz-progress-bar" class="bg-cyan-500 h-1 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                </div>
                <!-- Canvas injected here -->
            </div>
        </div>

        <!-- VIEW: INSPECT (Model Diagnostics) -->
        <div id="view-inspect" class="animate-fade-in hidden h-[calc(100vh-140px)] flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <div>
                    <h2 class="text-2xl font-bold text-white">üîç Model Inspector</h2>
                    <p class="text-gray-400 text-sm">Diagnose why models fail to load. View tensors and architecture details.</p>
                </div>
                <div class="flex items-center space-x-4">
                    <select id="inspect-model-select" onchange="onInspectModelChange()" class="bg-gray-800 text-white text-sm font-bold py-2 px-4 rounded-lg outline-none border border-gray-700 min-w-[250px]">
                        <option value="">Select a model to inspect...</option>
                    </select>
                    <button onclick="runInspection()" class="px-4 py-2 rounded-lg font-bold bg-amber-600 text-white hover:bg-amber-500 transition-all flex items-center space-x-2">
                        <span>üî¨ Inspect</span>
                    </button>
                </div>
            </div>

            <!-- Inspect Results Container -->
            <div id="inspect-results" class="flex-1 overflow-y-auto space-y-6">
                <div class="text-center py-20 text-gray-500">
                    <svg class="w-16 h-16 mx-auto mb-4 opacity-30" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <p>Select a model and click "Inspect" to view its structure</p>
                    <p class="text-sm mt-2">This helps identify unsupported layer types and missing files</p>
                </div>
            </div>
        </div>


    </div>

    <!-- Notification Toast -->
    <div id="toast" class="fixed bottom-5 right-5 bg-gray-800 border border-gray-700 text-white px-6 py-4 rounded-lg shadow-2xl transform translate-y-24 transition-transform duration-300 flex items-center space-x-3 z-50">
        <div class="w-2 h-2 bg-cyan-400 rounded-full animate-bounce"></div>
        <span id="toastMsg">Notification</span>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let ws;
        let retryInterval = 1000;
        let globalModels = {};
        let loomModels = {};  // LOOM model data from telemetry files
        let currentLoomModel = null;  // Currently selected LOOM model
        
        // --- Three.js Globals Moved Below ---

        function connect() {
            const proto = window.location.protocol === 'https:' ? 'wss' : 'ws';
            ws = new WebSocket(`${proto}://${window.location.host}/ws`);

            ws.onopen = () => {
                document.getElementById('connStatus').className = 'h-3 w-3 bg-green-500 rounded-full animate-pulse';
                document.getElementById('connText').innerText = 'CONNECTED';
                document.getElementById('connText').className = 'text-xs font-mono text-green-400';
                showToast('WebSocket Connected');
                retryInterval = 1000;
            };

            ws.onclose = () => {
                document.getElementById('connStatus').className = 'h-3 w-3 bg-red-500 rounded-full';
                document.getElementById('connText').innerText = 'DISCONNECTED';
                document.getElementById('connText').className = 'text-xs font-mono text-red-400';
                setTimeout(connect, retryInterval);
                retryInterval = Math.min(retryInterval * 2, 10000);
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.type === 'update') {
                    globalModels = msg.data;
                    renderTable(msg.data);
                    updateVizSelector(msg.data);
                    renderAnalysis(msg.data);
                    // Update compare view if active
                    if (!document.getElementById('view-compare').classList.contains('hidden')) {
                        renderCompareView();
                    }
                    if (!document.getElementById('view-visualize').classList.contains('hidden')) {
                         // update3DScene(); // Manual only
                    }
                    document.getElementById('streamStatus').classList.remove('hidden');
                    setTimeout(() => document.getElementById('streamStatus').classList.add('hidden'), 500);
                } else if (msg.type === 'inspect_result') {
                    renderInspectResult(msg.data);
                } else if (msg.type === 'loom_update') {
                    loomModels = msg.data;
                    updateLoomSelector(msg.data);
                    showToast(`Found ${Object.keys(msg.data).length} LOOM models`);
                }
            };
        }

        function sendAction(action, payload) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                if (action === 'analyze') currentTask = 'analyze';
                else if (action === 'compare') currentTask = 'compare';
                else if (action === 'verify') currentTask = 'verify';
                else if (action === 'benchmark') currentTask = 'benchmark';
                
                const msg = { action: action };
                if (payload) msg.payload = payload;
                
                ws.send(JSON.stringify(msg));
                if(action !== 'toggle_select') showToast(`Started: ${action}`);
                document.getElementById('progressContainer').classList.remove('hidden');
            } else {
                showToast('‚ùå Not connected');
            }
        }

        function toggleSelect(name) {
            sendAction('toggle_select', { name: name });
        }

        // --- Tabs ---
        function showTab(tab) {
            ['dashboard', 'analysis', 'compare', 'visualize', 'inspect'].forEach(t => {
                document.getElementById(`view-${t}`).classList.add('hidden');
                document.getElementById(`tab-${t}`).classList.remove('bg-gray-800', 'text-cyan-400', 'shadow');
                document.getElementById(`tab-${t}`).classList.add('text-gray-400');
            });

            document.getElementById(`view-${tab}`).classList.remove('hidden');
            document.getElementById(`tab-${tab}`).classList.add('bg-gray-800', 'text-cyan-400', 'shadow');
            document.getElementById(`tab-${tab}`).classList.remove('text-gray-400');
            
            if (tab === 'compare') renderCompareView();
            if (tab === 'visualize') {
                initThreeJS();
                // update3DScene(); // Manual trigger only
            }
            if (tab === 'inspect') {
                updateInspectModelSelector();
            }
        }
        
        // --- Progress ---
        let currentTask = null;
        let completedCount = 0;
        let totalTaskCount = 0;

        function updateProgress() {
            if (totalTaskCount > 0) {
                const percent = Math.round((completedCount / totalTaskCount) * 100);
                document.getElementById('progressBar').style.width = `${percent}%`;
                document.getElementById('progressText').innerText = `${completedCount} / ${totalTaskCount} (${percent}%)`;
                
                if (completedCount === totalTaskCount) {
                    setTimeout(() => {
                        document.getElementById('progressContainer').classList.add('hidden');
                    }, 2000);
                } else {
                    document.getElementById('progressContainer').classList.remove('hidden');
                }
            }
        }

        // --- Visualization Mode Toggle ---
        function setVizMode(mode) {
            vizMode = mode;
            ['real', 'blank', 'overlap', 'diff'].forEach(m => {
                const el = document.getElementById(`viz-mode-${m}`);
                 if (m === mode) {
                    el.classList.remove('text-gray-400', 'hover:text-white');
                    el.classList.add('bg-cyan-600', 'text-white');
                 } else {
                    el.classList.add('text-gray-400', 'hover:text-white');
                    el.classList.remove('bg-cyan-600', 'text-white');
                 }
            });
            // If scene is active, regenerate to reflect mode change
            if(scene && scene.children.length > 0) {
                 startVizGeneration();
            }
        }
        
        // --- PRNG for Deterministic Rendering ---
        let seedState = 1;
        function seed(s) {
            // Simple hash string to int
            seedState = s.split('').reduce((a,b)=>a+b.charCodeAt(0), 0);
        }
        function random() {
            const x = Math.sin(seedState++) * 10000;
            return x - Math.floor(x);
        }

        // --- STATE ---
        let currentVizModel = null;
        let layerPositions = []; // Store layer Z positions for camera fly-to
        let showInterLayerConnections = false; // Toggle for showing connections between layers
        let interLayerConnectionGroup = null; // Group for inter-layer connection lines
        let layerNodePositions = []; // Store neuron positions per layer for inter-layer connections
        
        function toggleInterLayerConnections() {
            showInterLayerConnections = document.getElementById('viz-connections-toggle').checked;
            
            if (!scene) return;
            
            // Remove existing inter-layer connections
            if (interLayerConnectionGroup) {
                scene.remove(interLayerConnectionGroup);
                interLayerConnectionGroup = null;
            }
            
            // If enabled and we have layer data, render connections
            if (showInterLayerConnections && layerNodePositions.length > 1) {
                renderInterLayerConnections();
            }
        }
        
        function renderInterLayerConnections() {
            if (!scene || layerNodePositions.length < 2) return;
            
            interLayerConnectionGroup = new THREE.Group();
            interLayerConnectionGroup.name = 'inter-layer-connections';
            
            // Draw connections between consecutive layers
            for (let i = 0; i < layerNodePositions.length - 1; i++) {
                const currentLayer = layerNodePositions[i];
                const nextLayer = layerNodePositions[i + 1];
                
                if (!currentLayer || !nextLayer || currentLayer.length === 0 || nextLayer.length === 0) continue;
                
                const lineGeo = new THREE.BufferGeometry();
                const linePos = [];
                const lineCols = [];
                
                // Number of connections to draw (limit for performance)
                const connectionCount = Math.min(100, Math.min(currentLayer.length, nextLayer.length));
                
                for (let c = 0; c < connectionCount; c++) {
                    // Sample random neurons from each layer
                    const srcIdx = Math.floor(Math.random() * currentLayer.length);
                    const dstIdx = Math.floor(Math.random() * nextLayer.length);
                    
                    const src = currentLayer[srcIdx];
                    const dst = nextLayer[dstIdx];
                    
                    linePos.push(src.x, src.y, src.z);
                    linePos.push(dst.x, dst.y, dst.z);
                    
                    // Gradient color from current to next layer
                    const strength = 0.3 + Math.random() * 0.5;
                    // Use a flowing gradient color (cyan to purple)
                    const startColor = new THREE.Color(0x06b6d4).multiplyScalar(strength);
                    const endColor = new THREE.Color(0xa855f7).multiplyScalar(strength);
                    
                    lineCols.push(startColor.r, startColor.g, startColor.b);
                    lineCols.push(endColor.r, endColor.g, endColor.b);
                }
                
                lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
                lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(lineCols, 3));
                
                const lineMat = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending
                });
                
                const lines = new THREE.LineSegments(lineGeo, lineMat);
                interLayerConnectionGroup.add(lines);
            }
            
            scene.add(interLayerConnectionGroup);
        }

        function onVizModelChange() {
            const select = document.getElementById('viz-model-select');
            const modelName = select.value;
            currentVizModel = globalModels[modelName] || null;
            
            const layerSelect = document.getElementById('viz-layer-select');
            layerSelect.innerHTML = '<option value="">All Layers (Overview)</option>';
            
            if (currentVizModel && currentVizModel.analysis && currentVizModel.analysis.layers) {
                currentVizModel.analysis.layers.forEach((l, idx) => {
                    const opt = document.createElement('option');
                    opt.value = idx;
                    opt.innerText = `${idx+1}. ${l.type.split('.').pop()} (${(l.params/1000000).toFixed(2)}M)`;
                    layerSelect.appendChild(opt);
                });
            }
        }
        
        function onVizLayerChange() {
            const select = document.getElementById('viz-layer-select');
            const idx = select.value;
            
            if (idx === '' || !layerPositions[idx]) {
                // Reset to overview position
                flyTo(new THREE.Vector3(30, 30, 50), new THREE.Vector3(0, 0, 0));
                return;
            }
            
            const z = layerPositions[idx].z;
            flyTo(new THREE.Vector3(10, 5, z + 20), new THREE.Vector3(0, 0, z));
            
            // Show layer details in panel
            if (currentVizModel && currentVizModel.analysis) {
                const l = currentVizModel.analysis.layers[idx];
                showLayerDetails({
                    layerName: l.name,
                    layerType: l.type,
                    params: l.params,
                    modelName: currentVizModel.name,
                    stats: { mean: l.mean, std: l.std_dev }
                });
            }
        }
        
        // --- LOOM Model Functions ---
        
        function scanLoomFolder() {
            const folderPath = document.getElementById('loom-folder-path').value;
            if (!folderPath) {
                showToast('‚ùå Please enter a folder path');
                return;
            }
            sendAction('scan_loom_folder', { path: folderPath });
        }
        
        function updateLoomSelector(models) {
            const select = document.getElementById('viz-loom-select');
            select.innerHTML = '<option value="">LOOM Models...</option>';
            
            // Sort by model name
            const sortedNames = Object.keys(models).sort();
            
            for (const name of sortedNames) {
                const model = models[name];
                const opt = document.createElement('option');
                opt.value = name;
                const layers = model.telemetry ? model.telemetry.total_layers : 0;
                const params = model.telemetry ? model.telemetry.total_parameters : 0;
                opt.innerText = `${name} (${layers}L, ${params}P)`;
                select.appendChild(opt);
            }
        }
        
        function onLoomModelChange() {
            const select = document.getElementById('viz-loom-select');
            const modelName = select.value;
            currentLoomModel = loomModels[modelName] || null;
        }
        
        async function loadLoomModel() {
            if (!scene) initThreeJS();
            
            const select = document.getElementById('viz-loom-select');
            const modelName = select.value;
            
            if (!modelName || !loomModels[modelName]) {
                showToast('‚ùå Please select a LOOM model first');
                return;
            }
            
            const model = loomModels[modelName];
            currentLoomModel = model;
            
            if (!model.telemetry || !model.telemetry.layers) {
                showToast('‚ùå Model has no telemetry data');
                return;
            }
            
            const loader = document.getElementById('viz-loading');
            const progress = document.getElementById('viz-progress-bar');
            const text = document.getElementById('viz-loading-text');
            
            loader.classList.remove('hidden');
            progress.style.width = '0%';
            text.innerText = 'Building LOOM Network...';
            
            await new Promise(r => requestAnimationFrame(r));
            
            // Clear scene
            const toRemove = [];
            scene.traverse((child) => {
                if ((child.isMesh || child.isPoints || child.isLine || child.isSprite) && child.name !== 'helper') toRemove.push(child);
            });
            toRemove.forEach(c => { scene.remove(c); if(c.geometry) c.geometry.dispose(); });
            interactableObjects = [];
            layerPositions = [];
            layerNodePositions = [];
            
            // Clear existing inter-layer connections
            if (interLayerConnectionGroup) {
                scene.remove(interLayerConnectionGroup);
                interLayerConnectionGroup = null;
            }
            
            const telemetry = model.telemetry;
            const group = new THREE.Group();
            const totalLayers = telemetry.layers.length;
            let processed = 0;
            
            // Model Title Label
            group.add(createLabel(modelName, new THREE.Vector3(0, 18, 0), 1.5));
            
            let layerIdx = 0; // Track layer index for all rendered items
            
            for (let i = 0; i < totalLayers; i++) {
                const l = telemetry.layers[i];
                
                // Progress
                const pct = Math.round((processed / totalLayers) * 100);
                progress.style.width = `${pct}%`;
                text.innerText = `Layer ${i+1}/${totalLayers}: ${l.type}...`;
                if (i % 3 === 0) await new Promise(r => setTimeout(r, 5)); // Yield
                
                // Calculate Z position based on grid position for better spatial layout
                const gridZ = l.grid_col * 20;  // Increased spacing
                const cellOffset = l.cell_layer * 3;
                const z = gridZ + cellOffset;
                
                // Check if this is a parallel layer with branches
                if (l.type.toLowerCase() === 'parallel' && l.branches && l.branches.length > 0) {
                    // Render each branch as a separate visual element spread vertically
                    const branchCount = l.branches.length;
                    const branchSpacing = 5; // Vertical spacing between branches
                    const totalHeight = (branchCount - 1) * branchSpacing;
                    const startY = totalHeight / 2;
                    
                    // Render container label for the parallel group
                    group.add(createLabel(`[${l.grid_row},${l.grid_col}] parallel (${branchCount} branches)`, 
                        new THREE.Vector3(0, startY + 5, z), 0.6));
                    
                    for (let bIdx = 0; bIdx < branchCount; bIdx++) {
                        const branch = l.branches[bIdx];
                        const branchY = startY - (bIdx * branchSpacing);
                        
                        // Color by branch type
                        let colorHex = getLayerColor(branch.type);
                        
                        seed(modelName + branch.type + i + bIdx);
                        renderLoomLayer(group, branch, z, branchY, colorHex, modelName, layerIdx, true, bIdx);
                        
                        layerPositions[layerIdx] = { z: z };
                        layerIdx++;
                    }
                } else {
                    // Regular layer - render at y=0
                    const yOffset = l.grid_row * 10;
                    
                    let colorHex = getLayerColor(l.type);
                    
                    seed(modelName + l.type + i);
                    renderLoomLayer(group, l, z, yOffset, colorHex, modelName, layerIdx, false, 0);
                    
                    layerPositions[layerIdx] = { z: z };
                    layerIdx++;
                }
                
                processed++;
            }
            
            scene.add(group);
            
            // Render inter-layer connections if toggle is enabled
            if (showInterLayerConnections && layerNodePositions.length > 1) {
                renderInterLayerConnections();
            }
            
            // Reset Camera
            flyTo(new THREE.Vector3(30, 30, 50), new THREE.Vector3(0, 0, 0));
            
            progress.style.width = '100%';
            text.innerText = 'Done! Click layers to inspect.';
            setTimeout(() => loader.classList.add('hidden'), 500);
        }
        
        // Helper to get color based on layer type
        function getLayerColor(layerType) {
            const typeL = (layerType || '').toLowerCase();
            if (typeL.includes("attn") || typeL.includes("mha") || typeL.includes("multihead")) return 0xa855f7; // purple
            if (typeL.includes("mlp") || typeL.includes("swiglu")) return 0x22c55e; // green
            if (typeL.includes("norm")) return 0xf97316; // orange
            if (typeL.includes("dense")) return 0x3b82f6; // blue
            if (typeL.includes("lstm")) return 0xec4899; // pink
            if (typeL.includes("rnn")) return 0xf472b6; // light pink
            if (typeL.includes("parallel")) return 0x8b5cf6; // violet
            if (typeL.includes("conv")) return 0x14b8a6; // teal
            return 0x06b6d4; // cyan default
        }
        
        function renderLoomLayer(group, l, z, yOffset, color, mName, layerIndex, isBranch = false, branchIndex = 0) {
            // Dimensions based on params
            const params = Math.max(l.parameters || 100, 100);
            const paramScale = Math.log10(params) / 5;
            const baseH = isBranch ? 4 : 8;  // Smaller for branches
            const baseW = isBranch ? 4 : 6;
            const h = baseH * paramScale;
            const w = baseW * paramScale;
            const neuronCount = Math.min(Math.max(30, Math.floor(params / 100)), 300);
            const connectionCount = Math.min(neuronCount * 15, 2000);
            
            // 1. Neurons as Points
            const nodeGeo = new THREE.BufferGeometry();
            const nodePos = [];
            const nodeColors = [];
            const baseColor = new THREE.Color(color);
            
            for(let i=0; i<neuronCount; i++) {
                const x = (random() - 0.5) * w;
                const y = (random() - 0.5) * h + yOffset;
                const zOffset = (random() - 0.5) * 3;
                
                nodePos.push(x, y, z + zOffset);
                
                const brightness = 0.6 + random() * 0.6;
                const c = baseColor.clone().multiplyScalar(brightness);
                nodeColors.push(c.r, c.g, c.b);
            }
            
            nodeGeo.setAttribute('position', new THREE.Float32BufferAttribute(nodePos, 3));
            nodeGeo.setAttribute('color', new THREE.Float32BufferAttribute(nodeColors, 3));
            
            const nodeMat = new THREE.PointsMaterial({ size: 0.2, vertexColors: true, transparent: true, opacity: 0.95 });
            const nodes = new THREE.Points(nodeGeo, nodeMat);
            group.add(nodes);
            
            // Store node positions for inter-layer connections
            const layerNodes = [];
            for (let i = 0; i < neuronCount; i++) {
                layerNodes.push({
                    x: nodePos[i * 3],
                    y: nodePos[i * 3 + 1],
                    z: nodePos[i * 3 + 2]
                });
            }
            layerNodePositions[layerIndex] = layerNodes;
            
            // 2. Internal Connections
            const lineGeo = new THREE.BufferGeometry();
            const linePos = [];
            const lineCols = [];
            
            for(let i=0; i<connectionCount; i++) {
                const inIdx = Math.floor(random() * neuronCount);
                const outIdx = Math.floor(random() * neuronCount);
                if (inIdx === outIdx) continue;
                
                linePos.push(
                    nodePos[inIdx*3], nodePos[inIdx*3+1], nodePos[inIdx*3+2],
                    nodePos[outIdx*3], nodePos[outIdx*3+1], nodePos[outIdx*3+2]
                );
                
                const strength = Math.pow(random(), 2);
                lineCols.push(baseColor.r * strength, baseColor.g * strength, baseColor.b * strength);
                lineCols.push(baseColor.r * strength, baseColor.g * strength, baseColor.b * strength);
            }
            lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
            lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(lineCols, 3));
            
            const lineMat = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.35, blending: THREE.AdditiveBlending });
            const lines = new THREE.LineSegments(lineGeo, lineMat);
            group.add(lines);
            
            // 3. Label with grid position and type
            const gridPos = `[${l.grid_row},${l.grid_col}]`;
            const branchInfo = isBranch ? `B${branchIndex}:` : '';
            const labelText = isBranch ? `${branchInfo}${l.type}` : `${gridPos} ${l.type}`;
            const labelScale = isBranch ? 0.4 : 0.5;
            group.add(createLabel(labelText, new THREE.Vector3(isBranch ? -3 : 0, yOffset + h/2 + 0.8, z), labelScale));
            
            // 4. HitBox for Click with rich telemetry info
            const hitBox = new THREE.Mesh(new THREE.BoxGeometry(w+2, h+2, 5), new THREE.MeshBasicMaterial({ visible: false }));
            hitBox.position.set(0, yOffset, z);
            hitBox.userData = { 
                layerName: isBranch ? `Branch ${branchIndex}: ${l.type}` : `Layer ${layerIndex} (${gridPos})`,
                layerType: l.type,
                params: l.parameters,
                modelName: mName,
                layerIndex: layerIndex,
                gridRow: l.grid_row,
                gridCol: l.grid_col,
                cellLayer: l.cell_layer,
                activation: l.activation || 'none',
                inputShape: l.input_shape,
                outputShape: l.output_shape,
                branches: l.branches,
                isLoom: true,
                isBranch: isBranch,
                branchIndex: branchIndex
            };
            interactableObjects.push(hitBox);
            group.add(hitBox);
        }
        
        function flyTo(targetPosition, targetLook) {
            if (!camera || !controls) return;
            
            const startPos = camera.position.clone();
            const startLook = controls.target.clone();
            let t = 0;
            
            function animate() {
                t += 0.03;
                if (t >= 1) t = 1;
                
                const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; // Ease in-out
                
                camera.position.lerpVectors(startPos, targetPosition, ease);
                controls.target.lerpVectors(startLook, targetLook, ease);
                controls.update();
                
                if (t < 1) requestAnimationFrame(animate);
            }
            animate();
        }

        async function startVizGeneration() {
            if (!scene) initThreeJS();
            
            const modelSelect = document.getElementById('viz-model-select');
            const modelName = modelSelect.value;
            
            const loader = document.getElementById('viz-loading');
            const progress = document.getElementById('viz-progress-bar');
            const text = document.getElementById('viz-loading-text');
            
            if(!modelName) {
                 showToast("Please select a model first!");
                 return;
            }
            
            const m = globalModels[modelName];
            if (!m || !m.analysis) {
                 showToast("Model analysis data missing. Please run Analyze first.");
                 return;
            }
            
            currentVizModel = m;

            loader.classList.remove('hidden');
            progress.style.width = '0%';
            text.innerText = 'Building Neural Architecture...';
            
            await new Promise(r => requestAnimationFrame(r));
            
            // Clear scene
            const toRemove = [];
            scene.traverse((child) => {
                if ((child.isMesh || child.isPoints || child.isLine || child.isSprite) && child.name !== 'helper') toRemove.push(child);
            });
            toRemove.forEach(c => { scene.remove(c); if(c.geometry) c.geometry.dispose(); });
            interactableObjects = [];
            layerPositions = [];
            layerNodePositions = []; // Clear stored node positions for inter-layer connections
            
            // Clear existing inter-layer connections
            if (interLayerConnectionGroup) {
                scene.remove(interLayerConnectionGroup);
                interLayerConnectionGroup = null;
            }

            const analysis = m.analysis;
            const group = new THREE.Group();
            const totalLayers = analysis.layers.length;
            let processed = 0;
            
            // Model Title Label
            group.add(createLabel(m.name, new THREE.Vector3(0, 18, 0), 1.5));
            
            for (let i = 0; i < totalLayers; i++) {
                const l = analysis.layers[i];

                // Progress
                const pct = Math.round((processed / totalLayers) * 100);
                progress.style.width = `${pct}%`;
                text.innerText = `Layer ${i+1}/${totalLayers}: ${l.name.substring(0, 40)}...`;
                if (i % 3 === 0) await new Promise(r => setTimeout(r, 5)); // Yield
                
                const z = i * 12 - (totalLayers * 6); // Spread
                layerPositions[i] = { z: z };
                
                // Color by type
                let colorHex = 0x06b6d4; 
                if (l.type.toLowerCase().includes("attn")) colorHex = 0xa855f7; 
                if (l.type.toLowerCase().includes("mlp")) colorHex = 0x22c55e;
                if (l.type.toLowerCase().includes("norm")) colorHex = 0xf97316;
                if (l.type.toLowerCase().includes("embed")) colorHex = 0x3b82f6;

                // Render Layer
                seed(l.name + "viz");
                renderDetailedLayer(group, l, z, colorHex, m.name, i);
                
                processed++;
            }
            
            scene.add(group);
            
            // Render inter-layer connections if toggle is enabled
            if (showInterLayerConnections && layerNodePositions.length > 1) {
                renderInterLayerConnections();
            }
            
            // Reset Camera
            flyTo(new THREE.Vector3(30, 30, 50), new THREE.Vector3(0, 0, 0));
            
            progress.style.width = '100%';
            text.innerText = 'Done! Click layers or use dropdown to inspect.';
            setTimeout(() => loader.classList.add('hidden'), 500);
        }
        
        function renderDetailedLayer(group, l, z, color, mName, layerIndex) {
             // Dimensions based on params
             const baseH = 10;
             const baseW = 8;
             const paramScale = Math.log10(Math.max(l.params, 100)) / 6; // 0.3 to 1.2 ish
             const h = baseH * paramScale;
             const w = baseW * paramScale;
             const neuronCount = Math.min(Math.max(50, Math.floor(l.params / 50000)), 500); // 50 to 500 neurons
             const connectionCount = Math.min(neuronCount * 20, 3000); // Up to 3000 lines
             
             // 1. Neurons as Points
             const nodeGeo = new THREE.BufferGeometry();
             const nodePos = [];
             const nodeColors = [];
             const baseColor = new THREE.Color(color);
             
             for(let i=0; i<neuronCount; i++) {
                 const x = (random() - 0.5) * w;
                 const y = (random() - 0.5) * h;
                 const zOffset = (random() - 0.5) * 4;
                 
                 nodePos.push(x, y, z + zOffset);
                 
                 // Value-based color intensity (simulated from std_dev)
                 const val = Math.abs(gaussianRandom(l.mean || 0, l.std_dev || 0.1));
                 const brightness = Math.min(0.5 + val * 5, 1.5);
                 const c = baseColor.clone().multiplyScalar(brightness);
                 nodeColors.push(c.r, c.g, c.b);
             }
             
             nodeGeo.setAttribute('position', new THREE.Float32BufferAttribute(nodePos, 3));
             nodeGeo.setAttribute('color', new THREE.Float32BufferAttribute(nodeColors, 3));
             
             const nodeMat = new THREE.PointsMaterial({ size: 0.2, vertexColors: true, transparent: true, opacity: 0.95 });
             const nodes = new THREE.Points(nodeGeo, nodeMat);
             group.add(nodes);
             
             // Store node positions for inter-layer connections
             const layerNodes = [];
             for (let i = 0; i < neuronCount; i++) {
                 layerNodes.push({
                     x: nodePos[i * 3],
                     y: nodePos[i * 3 + 1],
                     z: nodePos[i * 3 + 2]
                 });
             }
             layerNodePositions[layerIndex] = layerNodes;
             
             // 2. Internal Connections (The Sparse Web)
             const lineGeo = new THREE.BufferGeometry();
             const linePos = [];
             const lineCols = [];
             
             for(let i=0; i<connectionCount; i++) {
                 const inIdx = Math.floor(random() * neuronCount);
                 const outIdx = Math.floor(random() * neuronCount);
                 if (inIdx === outIdx) continue;
                 
                 linePos.push(
                     nodePos[inIdx*3], nodePos[inIdx*3+1], nodePos[inIdx*3+2],
                     nodePos[outIdx*3], nodePos[outIdx*3+1], nodePos[outIdx*3+2]
                 );
                 
                 // Opacity represents "weight strength" (simulated)
                 const strength = Math.pow(random(), 2);
                 lineCols.push(baseColor.r * strength, baseColor.g * strength, baseColor.b * strength);
                 lineCols.push(baseColor.r * strength, baseColor.g * strength, baseColor.b * strength);
             }
             lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
             lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(lineCols, 3));
             
             const lineMat = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.35, blending: THREE.AdditiveBlending });
             const lines = new THREE.LineSegments(lineGeo, lineMat);
             group.add(lines);
             
             // 3. Label
             const shortType = l.type.split('.').pop().substring(0, 15);
             group.add(createLabel(shortType, new THREE.Vector3(0, h/2 + 1.5, z), 0.6));
             
             // 4. HitBox for Click
             const hitBox = new THREE.Mesh(new THREE.BoxGeometry(w+2, h+2, 5), new THREE.MeshBasicMaterial({ visible: false }));
             hitBox.position.set(0, 0, z);
             hitBox.userData = { 
                 layerName: l.name, 
                 layerType: l.type, 
                 params: l.params, 
                 modelName: mName, 
                 layerIndex: layerIndex,
                 stats: { mean: l.mean, std: l.std_dev } 
             };
             interactableObjects.push(hitBox);
             group.add(hitBox);
        }
        
        function gaussianRandom(mean, std) {
            // Box-Muller transform for simulated values
            const u1 = Math.random();
            const u2 = Math.random();
            const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            return mean + z * std;
        }
        
        // --- Hyper-Renderers ---

        function renderHyperMLP(group, l, z, color, mName, isBlank) {
             const h = 10;
             const w = 6;
             const count = 100; // Dense count
             
             // Input Neurons
             const inputGeo = new THREE.BufferGeometry();
             const inputPos = [];
             for(let i=0; i<count; i++) {
                 inputPos.push((random()-0.5)*w, (random()-0.5)*h, -2); // SEEDED
             }
             inputGeo.setAttribute('position', new THREE.Float32BufferAttribute(inputPos, 3));
             const inputPoints = new THREE.Points(inputGeo, new THREE.PointsMaterial({color: isBlank ? 0x888888 : 0xffffff, size: 0.15}));
             inputPoints.position.set(0, 0, z);
             
             // Output Neurons
             const outputGeo = new THREE.BufferGeometry();
             const outputPos = [];
             for(let i=0; i<count; i++) {
                 outputPos.push((random()-0.5)*w, (random()-0.5)*h, 2); // SEEDED
             }
             outputGeo.setAttribute('position', new THREE.Float32BufferAttribute(outputPos, 3));
             const outputPoints = new THREE.Points(outputGeo, new THREE.PointsMaterial({color: color, size: 0.2}));
             outputPoints.position.set(0, 0, z);
             
             // Connections (Hyper Dense)
             // We draw lines from inputs to outputs
             const lineGeo = new THREE.BufferGeometry();
             const linePos = [];
             const lineColors = [];
             const colorObj = new THREE.Color(color);
             const whiteObj = new THREE.Color(0xffffff);

             // Draw 2000 lines
             for(let i=0; i<2000; i++) {
                 const startIdx = Math.floor(random() * count) * 3; 
                 const endIdx = Math.floor(random() * count) * 3;
                 
                 // Sim Weight Strength for "Real" check
                 const weightVal = isBlank ? (random() * 0.1) : (random() * Math.abs(l.mean) * 100); 
                 
                 linePos.push(
                     inputPos[startIdx], inputPos[startIdx+1], -2 + z,
                     outputPos[endIdx], outputPos[endIdx+1], 2 + z
                 );
             }
             lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
             
             const op = isBlank ? 0.05 : 0.15;
             const lines = new THREE.LineSegments(lineGeo, new THREE.LineBasicMaterial({ color: color, opacity: op, transparent: true }));
             
             // HitBox
             const hitBox = new THREE.Mesh(new THREE.BoxGeometry(w+2, h+2, 5), new THREE.MeshBasicMaterial({ visible: false }));
             hitBox.position.set(0, 0, z);
             hitBox.userData = { layerName: l.name, layerType: isBlank ? "Uninitialized" : l.type, params: l.params, modelName: mName, stats: { mean: l.mean, std: l.std_dev } };
             interactableObjects.push(hitBox);
             group.add(hitBox);

             group.add(inputPoints);
             group.add(outputPoints);
             group.add(lines);
             if(!isBlank) group.add(createLabel(l.type.split('.').pop(), new THREE.Vector3(0, h/2 + 2, z)));
        }

        function renderHyperAttention(group, l, z, color, mName, isBlank) {
             const numHeads = 12;
             const radius = 4;
             
             const attGroup = new THREE.Group();
             attGroup.position.set(0, 0, z);
             
             // Context center
             const centerMesh = new THREE.Mesh(
                new THREE.SphereGeometry(1, 16, 16),
                new THREE.MeshStandardMaterial({ color: isBlank ? 0x888888 : 0xffffff, transparent: true, opacity: 0.5 })
             );
             attGroup.add(centerMesh);

             for(let i=0; i<numHeads; i++) {
                const angle = (i / numHeads) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const mat = new THREE.MeshStandardMaterial({ color: color, transparent: true, opacity: isBlank ? 0.4 : 1 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, 0);
                attGroup.add(mesh);
                
                // Dense Context Lines to Center
                const lineGeo = new THREE.BufferGeometry();
                const pos = [];
                for(let k=0; k<20; k++) { // 20 lines per head
                    pos.push(
                        x + (random()-0.5), y + (random()-0.5), 0,
                        (random()-0.5), (random()-0.5), 0
                    );
                }
                lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                const lines = new THREE.LineSegments(lineGeo, new THREE.LineBasicMaterial({ color: isBlank ? 0x555555 : 0xffffff, opacity: isBlank ? 0.05 : 0.2, transparent: true }));
                attGroup.add(lines);
            }
             
            // HitBox
             const hitBox = new THREE.Mesh(new THREE.BoxGeometry(8, 8, 2), new THREE.MeshBasicMaterial({ visible: false }));
             hitBox.position.set(0, 0, z);
             hitBox.userData = { layerName: l.name, layerType: l.type, params: l.params, modelName: mName, stats: { mean: l.mean, std: l.std_dev } };
             interactableObjects.push(hitBox);
             group.add(hitBox);

            group.add(attGroup);
            if(!isBlank) group.add(createLabel("Attn", new THREE.Vector3(0, 6, z)));
        }

        function renderHyperGeneric(group, l, z, color, mName, isBlank) {
             renderGenericLayer(group, l, z, color, mName, isBlank);
        }
        
        // --- Render Helpers ---
        // (Helpers updated to use random() instead of Math.random())

        function createLabel(text, position, size = 1) {
            // ... (keep existing)
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = 'rgba(0,0,0,0)'; 
            context.fillRect(0, 0, 256, 64);
            context.font = 'bold 24px monospace';
            context.fillStyle = 'rgba(255,255,255,0.8)';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 128, 32);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(4 * size, 1 * size, 1);
            sprite.position.copy(position);
            return sprite;
        }

        function renderGenericLayer(group, l, z, color, mName, isGhost=false) {
            const params = Math.max(100, l.params || 1000); 
            const h = Math.max(1, Math.log10(params));
            
            const pointsMat = new THREE.PointsMaterial({ 
                color: color, 
                size: isGhost ? 0.1 : 0.15, 
                transparent: true, 
                opacity: isGhost ? 0.3 : 0.8 
            });
            const pointsGeo = new THREE.BufferGeometry();
            
            const count = Math.min(1000, Math.floor(params / 10000));
            const positions = new Float32Array(count * 3);
            
            for(let i=0; i<count; i++) {
                positions[i*3] = (random() - 0.5) * 4; // SEEDED
                positions[i*3+1] = (random() - 0.5) * h;
                positions[i*3+2] = (random() - 0.5) * 1; 
            }
            pointsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const points = new THREE.Points(pointsGeo, pointsMat);
            points.position.set(0, h/2, z);
            
            // Interaction Data
            points.userData = { layerName: l.name, layerType: l.type, params: params, modelName: mName, stats: { mean: l.mean, std: l.std_dev, min: l.min, max: l.max } };
            
            if(!isGhost) {
                const hitGeo = new THREE.BoxGeometry(4, h, 1);
                const hitBox = new THREE.Mesh(hitGeo, new THREE.MeshBasicMaterial({ visible: false }));
                hitBox.position.copy(points.position);
                hitBox.userData = points.userData;
                group.add(hitBox);
                interactableObjects.push(hitBox);
                group.add(createLabel(l.type, new THREE.Vector3(0, h + 1, z)));
            }
             
            group.add(points);
        }

        function renderMLPLayer(group, l, z, color, mName, isGhost=false) {
             const h = 4;
             const w = 3;
             const count = 50; 
             
             // Input Wall
             const inputGeo = new THREE.BufferGeometry();
             const inputPos = [];
             for(let i=0; i<count; i++) {
                 inputPos.push((random()-0.5)*w, (random()-0.5)*h, -0.5); // SEEDED
             }
             inputGeo.setAttribute('position', new THREE.Float32BufferAttribute(inputPos, 3));
             const inputPoints = new THREE.Points(inputGeo, new THREE.PointsMaterial({color: isGhost ? 0x555555 : 0xffffff, size: 0.1, transparent: true, opacity: isGhost ? 0.3 : 1}));
             inputPoints.position.set(0, h/2, z);
             
             // Output Wall
             const outputGeo = new THREE.BufferGeometry();
             const outputPos = [];
             for(let i=0; i<count; i++) {
                 outputPos.push((random()-0.5)*w, (random()-0.5)*h, 0.5); // SEEDED
             }
             outputGeo.setAttribute('position', new THREE.Float32BufferAttribute(outputPos, 3));
             const outputPoints = new THREE.Points(outputGeo, new THREE.PointsMaterial({color: color, size: 0.15, transparent: true, opacity: isGhost ? 0.3 : 1}));
             outputPoints.position.set(0, h/2, z);
             
             // Connections
             const lineGeo = new THREE.BufferGeometry();
             const linePos = [];
             for(let i=0; i<100; i++) {
                 const startIdx = Math.floor(random() * count) * 3; // SEEDED
                 const endIdx = Math.floor(random() * count) * 3;
                 
                 linePos.push(
                     inputPos[startIdx], inputPos[startIdx+1] + h/2, -0.5 + z,
                     outputPos[endIdx], outputPos[endIdx+1] + h/2, 0.5 + z
                 );
             }
             lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
             const lines = new THREE.LineSegments(lineGeo, new THREE.LineBasicMaterial({ color: color, opacity: isGhost ? 0.05 : 0.2, transparent: true }));
             
             if(!isGhost) {
                 const hitBox = new THREE.Mesh(new THREE.BoxGeometry(w, h, 2), new THREE.MeshBasicMaterial({ visible: false }));
                 hitBox.position.set(0, h/2, z);
                 hitBox.userData = { layerName: l.name, layerType: l.type, params: l.params, modelName: mName, stats: { mean: l.mean, std: l.std_dev, min: l.min, max: l.max } };
                 group.add(hitBox);
                 interactableObjects.push(hitBox);
                 if (l.std_dev) {
                     group.add(createLabel(`œÉ=${l.std_dev.toFixed(4)}`, new THREE.Vector3(0, h + 1, z), 0.8));
                 }
             }

             group.add(inputPoints);
             group.add(outputPoints);
             group.add(lines);
        }

        function renderAttentionLayer(group, l, z, color, mName, isGhost=false) {
            const numHeads = 8;
            const radius = 2;
            const headSize = 0.4;
            
            const attGroup = new THREE.Group();
            attGroup.position.set(0, 3, z);
            
            for(let i=0; i<numHeads; i++) {
                const angle = (i / numHeads) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                const geo = new THREE.BoxGeometry(headSize, headSize, headSize);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    transparent: true, 
                    opacity: isGhost ? 0.3 : 1,
                    wireframe: isGhost
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, 0);
                attGroup.add(mesh);
                
                const lineGeo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(x, y, 0),
                    new THREE.Vector3(0, 0, 0)
                ]);
                const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: isGhost ? 0x555555 : 0xffffff, opacity: isGhost ? 0.1 : 0.3, transparent: true }));
                attGroup.add(line);
            }
            
            const centerMesh = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshStandardMaterial({ color: isGhost ? 0x555555 : 0xffffff, wireframe: true, transparent: true, opacity: isGhost ? 0.3 : 1 })
            );
            attGroup.add(centerMesh);
            
            if(!isGhost) {
                const hitBox = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 1), new THREE.MeshBasicMaterial({ visible: false }));
                hitBox.position.set(0, 3, z);
                hitBox.userData = { layerName: l.name, layerType: l.type, params: l.params, modelName: mName, stats: { mean: l.mean, std: l.std_dev, min: l.min, max: l.max } };
                group.add(hitBox);
                interactableObjects.push(hitBox);
                group.add(createLabel("MHA", new THREE.Vector3(0, 5.5, z)));
            }
            
            group.add(attGroup);
        }

        // --- Three.js Globals ---
        let scene, camera, renderer, controls, raycaster, mouse;
        let vizMode = 'real'; // real, blank, diff
        let animationId;
        let interactableObjects = []; // Store meshes/points for raycasting

        // ... (connect function remains same)

        // --- Three.js Logic ---
        function initThreeJS() {
            if (scene) return; // Already init
            
            const container = document.getElementById('three-container');
            
            // Raycaster setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827); 
            // Fog removed

            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.01, 1000); // Near plane 0.01 for macro
            camera.position.set(20, 20, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Interaction
            renderer.domElement.addEventListener('pointerdown', onDocumentMouseDown, false);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 0.1; // Allow extreme closeups

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 2); 
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Grid
            const gridHelper = new THREE.GridHelper(100, 100, 0x374151, 0x1f2937);
            scene.add(gridHelper);

            // Animate
            const animate = function () {
                animationId = requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            };
            animate();

            window.addEventListener('resize', () => {
                if(container.offsetParent) { 
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                }
            });
        }

        let isExpanded = false; // Track if we're viewing layer internals

        function onDocumentMouseDown(event) {
            // If in expanded view, ignore layer clicks (allow orbit)
            if (isExpanded) return;
            
            event.preventDefault();
            
            const container = document.getElementById('three-container');
            const rect = container.getBoundingClientRect();
            
            mouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(interactableObjects);
            
            if (intersects.length > 0) {
                // Focus on the first hit
                const hit = intersects[0];
                const userData = hit.object.userData;
                if (userData && userData.layerName) {
                     showLayerDetails(userData);
                }
            }
        }

        function update3DScene() {
            if (!scene) return;
            
            // Clear existing
            const toRemove = [];
            scene.traverse((child) => {
                if ((child.isMesh || child.isPoints) && child.name !== 'helper') toRemove.push(child);
            });
            toRemove.forEach(c => scene.remove(c));
            interactableObjects = [];

            const models = Object.values(globalModels).filter(m => m.selected && m.analysis);
            if(models.length === 0) return;

            let xOffset = -(models.length * 10) / 2; // Center the lineup
            const spacing = 15;

            models.forEach((m, idx) => {
                const group = new THREE.Group();
                const analysis = (vizMode === 'blank' && m.blank_analysis) ? m.blank_analysis : m.analysis;
                const comparison = m.blank_analysis; 
                
                if (!analysis) return;

                if (analysis.layers) {
                    analysis.layers.forEach((l, i) => {
                        // Height based on params
                        const h = Math.log10(l.params) / 1.5; 
                        const w = 4; // Width
                        const d = 2; // Depth
                        
                        let colorHex = 0x06b6d4; 
                        if (l.type.includes("attn")) colorHex = 0xa855f7; 
                        if (l.type.includes("mlp")) colorHex = 0x22c55e;
                        if (l.type.includes("norm")) colorHex = 0xf97316;
                        
                        if (vizMode === 'diff' && comparison && comparison.layers[i]) {
                             const diff = Math.abs(l.std_dev - comparison.layers[i].std_dev);
                             const intensity = Math.min(diff * 10, 1); 
                             colorHex = new THREE.Color().setHSL(0.7 - (intensity * 0.7), 1, 0.5).getHex();
                        }
                        
                        // Particle Cloud Logic
                        // More particles for detailed "every connection" feel
                        const particleCount = Math.max(100, Math.min(2000, l.params / 50000)); 
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array(particleCount * 3);
                        
                        for(let p=0; p<particleCount; p++) {
                            positions[p*3] = (Math.random() - 0.5) * w;
                            positions[p*3+1] = (Math.random() - 0.5) * h;
                            positions[p*3+2] = (Math.random() - 0.5) * d;
                        }
                        
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        const material = new THREE.PointsMaterial({ 
                            color: colorHex,
                            size: 0.15,
                            transparent: true,
                            opacity: 0.8
                        });
                        
                        const points = new THREE.Points(geometry, material);
                        points.position.y = h / 2;
                        points.position.z = i * 4 - (analysis.layers.length * 2);
                        
                        // User Data for Click Interaction
                        points.userData = { 
                            layerName: l.name, 
                            layerType: l.type, 
                            params: l.params, 
                            modelName: m.name,
                            stats: { mean: l.mean, std: l.std_dev, min: l.min, max: l.max } 
                        };
                        
                        // Add invisible HIT box because clicking points is hard
                        const hitGeo = new THREE.BoxGeometry(w, h, d);
                        const hitMat = new THREE.MeshBasicMaterial({ visible: false });
                        const hitBox = new THREE.Mesh(hitGeo, hitMat);
                        hitBox.position.copy(points.position);
                        hitBox.userData = points.userData; // Copy data
                        
                        group.add(points);
                        group.add(hitBox);
                        interactableObjects.push(hitBox);
                    });
                }
                
                group.position.x = xOffset;
                scene.add(group);
                
                xOffset += spacing;
            });
        }
        
        let expandedLayerGroup = null; // Track the expanded view
        
        function showLayerDetails(data) {
             console.log("Clicked Layer:", data);
             
             // Fly to layer
             if (data.layerIndex !== undefined && layerPositions[data.layerIndex]) {
                 const z = layerPositions[data.layerIndex].z;
                 // Fly MUCH closer for detail view
                 flyTo(new THREE.Vector3(0, 0, z + 15), new THREE.Vector3(0, 0, z));
                 
                 document.getElementById('viz-layer-select').value = data.layerIndex;
             }
             
             // Render Expanded View
             expandLayerView(data);
             
             // Update Panel (simpler stats only)
             if (document.getElementById('viz-details-panel')) {
                 updateVizPanel(data);
             } else {
                 createVizPanel(data);
             }
        }
        
        function expandLayerView(data) {
            if (!scene || !currentVizModel) return;
            
            isExpanded = true; // Block layer clicks
            
            // Remove previous expanded view
            if (expandedLayerGroup) {
                scene.remove(expandedLayerGroup);
                expandedLayerGroup = null;
            }
            
            const l = currentVizModel.analysis.layers[data.layerIndex];
            if (!l) return;
            
            expandedLayerGroup = new THREE.Group();
            const z = layerPositions[data.layerIndex]?.z || 0;
            expandedLayerGroup.position.set(0, 0, z);
            
            // Determine layer type for specific rendering
            const type = l.type.toLowerCase();
            
            // --- DETAILED INTERNAL RENDERING ---
            
            // 1. NEURONS (Much Higher Density)
            const neuronCount = Math.min(1000, Math.max(100, Math.floor(l.params / 10000)));
            const neuronGeo = new THREE.BufferGeometry();
            const neuronPos = [];
            const neuronColors = [];
            
            // Determine color by type
            let baseColor = new THREE.Color(0x06b6d4);
            if (type.includes("attn")) baseColor = new THREE.Color(0xa855f7);
            if (type.includes("mlp")) baseColor = new THREE.Color(0x22c55e);
            if (type.includes("norm")) baseColor = new THREE.Color(0xf97316);
            
            // Spatial Layout based on type
            let layoutW = 12, layoutH = 12, layoutD = 6;
            
            for (let i = 0; i < neuronCount; i++) {
                const x = (Math.random() - 0.5) * layoutW;
                const y = (Math.random() - 0.5) * layoutH;
                const zOff = (Math.random() - 0.5) * layoutD;
                
                neuronPos.push(x, y, zOff);
                
                // Simulate activation value
                const val = gaussianRandom(l.mean || 0, l.std_dev || 0.1);
                const brightness = Math.min(Math.max(0.3, 0.5 + Math.abs(val) * 3), 1.5);
                const c = baseColor.clone().multiplyScalar(brightness);
                neuronColors.push(c.r, c.g, c.b);
            }
            
            neuronGeo.setAttribute('position', new THREE.Float32BufferAttribute(neuronPos, 3));
            neuronGeo.setAttribute('color', new THREE.Float32BufferAttribute(neuronColors, 3));
            
            const neuronMat = new THREE.PointsMaterial({ size: 0.25, vertexColors: true, transparent: true, opacity: 1 });
            const neurons = new THREE.Points(neuronGeo, neuronMat);
            expandedLayerGroup.add(neurons);
            
            // 2. CONNECTIONS (Dense Web)
            const connectionCount = Math.min(5000, neuronCount * 10);
            const lineGeo = new THREE.BufferGeometry();
            const linePos = [];
            const lineCols = [];
            
            for (let i = 0; i < connectionCount; i++) {
                const inIdx = Math.floor(Math.random() * neuronCount);
                const outIdx = Math.floor(Math.random() * neuronCount);
                if (inIdx === outIdx) continue;
                
                linePos.push(
                    neuronPos[inIdx * 3], neuronPos[inIdx * 3 + 1], neuronPos[inIdx * 3 + 2],
                    neuronPos[outIdx * 3], neuronPos[outIdx * 3 + 1], neuronPos[outIdx * 3 + 2]
                );
                
                // Simulated weight strength
                const strength = Math.pow(Math.random(), 2);
                lineCols.push(baseColor.r * strength, baseColor.g * strength, baseColor.b * strength);
                lineCols.push(baseColor.r * strength, baseColor.g * strength, baseColor.b * strength);
            }
            
            lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
            lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(lineCols, 3));
            
            const lineMat = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
            const lines = new THREE.LineSegments(lineGeo, lineMat);
            expandedLayerGroup.add(lines);
            
            // 3. ATTENTION HEADS (If attention layer)
            if (type.includes("attn")) {
                const numHeads = 12;
                const headRadius = 6;
                
                // Q/K/V Neuron Sections (colored bands)
                const qkvColors = [
                    new THREE.Color(0x06b6d4), // Q - Cyan
                    new THREE.Color(0x22c55e), // K - Green
                    new THREE.Color(0xfbbf24)  // V - Yellow
                ];
                const qkvLabels = ['Query (Q)', 'Key (K)', 'Value (V)'];
                
                for (let qkv = 0; qkv < 3; qkv++) {
                    const yOffset = (qkv - 1) * 5; // Stack vertically
                    const sectionNeurons = 100;
                    
                    const secGeo = new THREE.BufferGeometry();
                    const secPos = [];
                    const secCols = [];
                    
                    for (let i = 0; i < sectionNeurons; i++) {
                        secPos.push(
                            (Math.random() - 0.5) * 10,
                            yOffset + (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 2 - 5 // Behind heads
                        );
                        secCols.push(qkvColors[qkv].r, qkvColors[qkv].g, qkvColors[qkv].b);
                    }
                    
                    secGeo.setAttribute('position', new THREE.Float32BufferAttribute(secPos, 3));
                    secGeo.setAttribute('color', new THREE.Float32BufferAttribute(secCols, 3));
                    
                    const secMat = new THREE.PointsMaterial({ size: 0.2, vertexColors: true, transparent: true, opacity: 0.9 });
                    expandedLayerGroup.add(new THREE.Points(secGeo, secMat));
                    
                    // Section Label
                    expandedLayerGroup.add(createLabel(qkvLabels[qkv], new THREE.Vector3(-7, yOffset, -5), 0.5));
                }
                
                // Attention Heads
                for (let h = 0; h < numHeads; h++) {
                    const angle = (h / numHeads) * Math.PI * 2;
                    const hx = Math.cos(angle) * headRadius;
                    const hy = Math.sin(angle) * headRadius;
                    
                    // Head block
                    const headGeo = new THREE.BoxGeometry(1, 1, 0.5);
                    const headMat = new THREE.MeshStandardMaterial({ 
                        color: 0xa855f7, 
                        emissive: 0xa855f7, 
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.9
                    });
                    const head = new THREE.Mesh(headGeo, headMat);
                    head.position.set(hx, hy, 0);
                    expandedLayerGroup.add(head);
                    
                    // Head Label
                    expandedLayerGroup.add(createLabel(`H${h+1}`, new THREE.Vector3(hx, hy + 1.2, 0), 0.4));
                    
                    // Attention lines to center
                    const attLineGeo = new THREE.BufferGeometry();
                    const attPos = [];
                    for (let k = 0; k < 30; k++) {
                        attPos.push(
                            hx + (Math.random() - 0.5) * 0.5, hy + (Math.random() - 0.5) * 0.5, 0,
                            (Math.random() - 0.5) * 1, (Math.random() - 0.5) * 1, 0
                        );
                    }
                    attLineGeo.setAttribute('position', new THREE.Float32BufferAttribute(attPos, 3));
                    const attLines = new THREE.LineSegments(attLineGeo, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true }));
                    expandedLayerGroup.add(attLines);
                }
                
                // Central Context Sphere
                const ctxGeo = new THREE.SphereGeometry(1.5, 32, 32);
                const ctxMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.2, transparent: true, opacity: 0.7 });
                const ctx = new THREE.Mesh(ctxGeo, ctxMat);
                expandedLayerGroup.add(ctx);
                expandedLayerGroup.add(createLabel("Context", new THREE.Vector3(0, -2.5, 0), 0.5));
            }
            
            // 4. MLP STRUCTURE (If MLP layer)
            if (type.includes("mlp")) {
                // Input wall
                const inputWallGeo = new THREE.PlaneGeometry(layoutW, layoutH);
                const inputWallMat = new THREE.MeshBasicMaterial({ color: 0x22c55e, side: THREE.DoubleSide, transparent: true, opacity: 0.1, wireframe: true });
                const inputWall = new THREE.Mesh(inputWallGeo, inputWallMat);
                inputWall.position.set(0, 0, -layoutD/2 - 1);
                expandedLayerGroup.add(inputWall);
                expandedLayerGroup.add(createLabel("Input", new THREE.Vector3(0, layoutH/2 + 1, -layoutD/2 - 1), 0.5));
                
                // Output wall
                const outputWall = new THREE.Mesh(inputWallGeo, new THREE.MeshBasicMaterial({ color: 0x22c55e, side: THREE.DoubleSide, transparent: true, opacity: 0.1, wireframe: true }));
                outputWall.position.set(0, 0, layoutD/2 + 1);
                expandedLayerGroup.add(outputWall);
                expandedLayerGroup.add(createLabel("Output", new THREE.Vector3(0, layoutH/2 + 1, layoutD/2 + 1), 0.5));
            }
            
            // 5. BIAS VISUALIZATION (Small Dots at Bottom)
            const biasGeo = new THREE.BufferGeometry();
            const biasPos = [];
            const biasCount = Math.min(50, neuronCount / 10);
            for (let i = 0; i < biasCount; i++) {
                biasPos.push((Math.random() - 0.5) * layoutW, -layoutH/2 - 1, (Math.random() - 0.5) * 2);
            }
            biasGeo.setAttribute('position', new THREE.Float32BufferAttribute(biasPos, 3));
            const biasMat = new THREE.PointsMaterial({ color: 0xfbbf24, size: 0.3, transparent: true, opacity: 0.9 });
            const biases = new THREE.Points(biasGeo, biasMat);
            expandedLayerGroup.add(biases);
            expandedLayerGroup.add(createLabel("Biases", new THREE.Vector3(0, -layoutH/2 - 2, 0), 0.4));
            
            // Add Title
            expandedLayerGroup.add(createLabel(l.type.split('.').pop(), new THREE.Vector3(0, layoutH/2 + 3, 0), 1));
            
            scene.add(expandedLayerGroup);
        }
        
        function createVizPanel(data) {
            const panel = document.createElement('div');
            panel.id = 'viz-details-panel';
            panel.className = 'absolute top-20 right-5 w-72 glass p-4 rounded-xl border border-gray-700 animate-fade-in z-20';
            document.getElementById('view-visualize').appendChild(panel);
            
            updateVizPanel(data);
        }
        
        function updateVizPanel(data) {
             const panel = document.getElementById('viz-details-panel');
             const type = data.layerType.toLowerCase();
             
             // Build component legend based on layer type
             let componentLegend = '';
             
             if (type.includes('attn')) {
                 componentLegend = `
                     <div class="mt-3 pt-2 border-t border-gray-700">
                         <div class="text-xs text-gray-400 mb-2">Components:</div>
                         <div class="grid grid-cols-2 gap-1 text-xs">
                             <div class="flex items-center"><span class="w-2 h-2 bg-purple-500 rounded mr-1"></span>Heads (H1-H12)</div>
                             <div class="flex items-center"><span class="w-2 h-2 bg-white rounded mr-1"></span>Context</div>
                             <div class="flex items-center"><span class="w-2 h-2 bg-cyan-400 rounded mr-1"></span>Q Neurons</div>
                             <div class="flex items-center"><span class="w-2 h-2 bg-green-400 rounded mr-1"></span>K Neurons</div>
                             <div class="flex items-center"><span class="w-2 h-2 bg-yellow-400 rounded mr-1"></span>V Neurons</div>
                             <div class="flex items-center"><span class="w-2 h-2 border border-white rounded mr-1"></span>Connections</div>
                         </div>
                     </div>
                 `;
             } else if (type.includes('mlp')) {
                 componentLegend = `
                     <div class="mt-3 pt-2 border-t border-gray-700">
                         <div class="text-xs text-gray-400 mb-2">Components:</div>
                         <div class="grid grid-cols-2 gap-1 text-xs">
                             <div class="flex items-center"><span class="w-2 h-2 bg-green-500 rounded mr-1"></span>Neurons</div>
                             <div class="flex items-center"><span class="w-2 h-2 bg-yellow-400 rounded mr-1"></span>Biases</div>
                             <div class="flex items-center"><span class="w-2 h-2 border border-green-500 mr-1"></span>Input Wall</div>
                             <div class="flex items-center"><span class="w-2 h-2 border border-green-500 mr-1"></span>Output Wall</div>
                             <div class="flex items-center col-span-2"><span class="w-6 h-px bg-green-500/50 mr-1"></span>Weight Connections</div>
                         </div>
                     </div>
                 `;
             } else if (type.includes('norm')) {
                 componentLegend = `
                     <div class="mt-3 pt-2 border-t border-gray-700">
                         <div class="text-xs text-gray-400 mb-2">Components:</div>
                         <div class="grid grid-cols-2 gap-1 text-xs">
                             <div class="flex items-center"><span class="w-2 h-2 bg-orange-400 rounded mr-1"></span>Scale (Œ≥)</div>
                             <div class="flex items-center"><span class="w-2 h-2 bg-yellow-400 rounded mr-1"></span>Shift (Œ≤)</div>
                         </div>
                     </div>
                 `;
             } else if (type.includes('embed')) {
                 componentLegend = `
                     <div class="mt-3 pt-2 border-t border-gray-700">
                         <div class="text-xs text-gray-400 mb-2">Components:</div>
                         <div class="text-xs text-gray-500">Token embeddings (vocab ‚Üí hidden dim)</div>
                     </div>
                 `;
             } else {
                 componentLegend = `
                     <div class="mt-3 pt-2 border-t border-gray-700">
                         <div class="text-xs text-gray-400 mb-2">Components:</div>
                         <div class="text-xs text-gray-500">Generic weight matrix</div>
                     </div>
                 `;
             }
             
             // Store for extraction
             window.currentLayerData = data;
             
             // LOOM-specific telemetry section
             let loomInfo = '';
             if (data.isLoom) {
                 loomInfo = `
                     <div class="mt-3 pt-2 border-t border-purple-700/50">
                         <div class="text-xs text-purple-400 mb-2 font-bold">üìç LOOM Grid Position</div>
                         <div class="grid grid-cols-3 gap-1 text-xs font-mono">
                             <div class="text-center"><span class="text-gray-500">Row</span><br><span class="text-white">${data.gridRow !== undefined ? data.gridRow : '-'}</span></div>
                             <div class="text-center"><span class="text-gray-500">Col</span><br><span class="text-white">${data.gridCol !== undefined ? data.gridCol : '-'}</span></div>
                             <div class="text-center"><span class="text-gray-500">Cell</span><br><span class="text-white">${data.cellLayer !== undefined ? data.cellLayer : '-'}</span></div>
                         </div>
                         ${data.activation ? `<div class="mt-2 flex justify-between"><span class="text-gray-500 text-xs">Activation</span><span class="text-green-400 text-xs">${data.activation}</span></div>` : ''}
                         ${data.inputShape ? `<div class="flex justify-between"><span class="text-gray-500 text-xs">Input</span><span class="text-cyan-400 text-xs">[${data.inputShape.join(', ')}]</span></div>` : ''}
                         ${data.outputShape ? `<div class="flex justify-between"><span class="text-gray-500 text-xs">Output</span><span class="text-cyan-400 text-xs">[${data.outputShape.join(', ')}]</span></div>` : ''}
                         ${data.branches && data.branches.length > 0 ? `<div class="mt-1 text-xs text-purple-300">‚Ü≥ ${data.branches.length} parallel branches</div>` : ''}
                     </div>
                 `;
             }
             
             panel.innerHTML = `
                <div class="flex justify-between items-start mb-3">
                    <h3 class="text-base font-bold text-white break-words w-48">${data.layerType.split('.').pop()}</h3>
                    <button onclick="closeExpandedView()" class="text-gray-400 hover:text-white">‚úï</button>
                </div>
                <div class="space-y-1 text-xs font-mono">
                    <div class="text-cyan-400 text-xs truncate" title="${data.layerName}">${data.layerName}</div>
                    <div class="h-px bg-gray-700 my-2"></div>
                    <div class="flex justify-between"><span class="text-gray-500">Params</span> <span class="text-white">${(data.params/1000000).toFixed(2)}M</span></div>
                    <div class="flex justify-between"><span class="text-gray-500">Mean</span> <span class="text-yellow-400">${typeof data.stats?.mean === 'number' ? data.stats.mean.toExponential(3) : '-'}</span></div>
                    <div class="flex justify-between"><span class="text-gray-500">StdDev</span> <span class="text-purple-400">${typeof data.stats?.std === 'number' ? data.stats.std.toFixed(5) : '-'}</span></div>
                </div>
                ${loomInfo}
                ${componentLegend}
                <div class="mt-3 pt-2 border-t border-gray-700">
                    <button onclick="extractFeatures()" class="w-full py-2 bg-purple-600/30 hover:bg-purple-600/50 text-purple-300 rounded text-xs font-bold border border-purple-500/40 transition-all">
                        üî¨ Extract Features
                    </button>
                </div>
             `;
        }
        
        function closeExpandedView() {
            if (expandedLayerGroup) {
                scene.remove(expandedLayerGroup);
                expandedLayerGroup = null;
            }
            isExpanded = false; // Re-enable layer clicks
            
            const panel = document.getElementById('viz-details-panel');
            if (panel) panel.remove();
            
            // Reset camera to overview
            flyTo(new THREE.Vector3(30, 30, 50), new THREE.Vector3(0, 0, 0));
        }
        
        function extractFeatures() {
            if (!window.currentLayerData || !currentVizModel || !scene) {
                showToast("No layer selected");
                return;
            }
            
            const data = window.currentLayerData;
            const l = currentVizModel.analysis.layers[data.layerIndex];
            if (!l) return;
            
            // Clear previous expanded view
            if (expandedLayerGroup) {
                scene.remove(expandedLayerGroup);
            }
            
            expandedLayerGroup = new THREE.Group();
            const z = layerPositions[data.layerIndex]?.z || 0;
            expandedLayerGroup.position.set(0, 0, z);
            
            const type = l.type.toLowerCase();
            
            // === FEATURE EXTRACTION VIEW ===
            // Spread out components spatially for clear inspection
            
            if (type.includes('attn')) {
                // --- ATTENTION: Show each Head SEPARATELY ---
                const numHeads = 12;
                const headSpacing = 4;
                
                // Q/K/V Label at top
                expandedLayerGroup.add(createLabel("üî¨ ATTENTION FEATURE EXTRACTION", new THREE.Vector3(0, 15, 0), 1));
                
                // Create individual head groups
                for (let h = 0; h < numHeads; h++) {
                    const hx = (h % 6 - 2.5) * headSpacing;  // 2 rows of 6
                    const hy = h < 6 ? 5 : -5;
                    
                    // Head Container Box
                    const boxGeo = new THREE.BoxGeometry(3, 3, 2);
                    const boxMat = new THREE.MeshStandardMaterial({
                        color: 0xa855f7,
                        transparent: true,
                        opacity: 0.2,
                        wireframe: true
                    });
                    const box = new THREE.Mesh(boxGeo, boxMat);
                    box.position.set(hx, hy, 0);
                    expandedLayerGroup.add(box);
                    
                    // Head Label
                    expandedLayerGroup.add(createLabel(`Head ${h+1}`, new THREE.Vector3(hx, hy + 2, 0), 0.5));
                    
                    // Q/K/V Neurons INSIDE head
                    const qkvColors = [0x06b6d4, 0x22c55e, 0xfbbf24];
                    const qkvNames = ['Q', 'K', 'V'];
                    
                    for (let qkv = 0; qkv < 3; qkv++) {
                        const neuronCount = 20;
                        const geo = new THREE.BufferGeometry();
                        const pos = [];
                        
                        for (let i = 0; i < neuronCount; i++) {
                            pos.push(
                                hx + (Math.random() - 0.5) * 2.5,
                                hy + (qkv - 1) * 0.8,
                                (Math.random() - 0.5) * 1.5
                            );
                        }
                        
                        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                        const mat = new THREE.PointsMaterial({ color: qkvColors[qkv], size: 0.15 });
                        expandedLayerGroup.add(new THREE.Points(geo, mat));
                    }
                }
                
                // Connections between heads ‚Üí Context
                expandedLayerGroup.add(createLabel("Context", new THREE.Vector3(0, 0, 5), 0.6));
                const ctxGeo = new THREE.SphereGeometry(1, 32, 32);
                const ctx = new THREE.Mesh(ctxGeo, new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.3 }));
                ctx.position.set(0, 0, 5);
                expandedLayerGroup.add(ctx);
                
            } else if (type.includes('mlp')) {
                // --- MLP: Show Gate, Up, Down Projections SEPARATELY ---
                expandedLayerGroup.add(createLabel("üî¨ MLP FEATURE EXTRACTION", new THREE.Vector3(0, 12, 0), 1));
                
                const projections = [
                    { name: 'Gate Proj', color: 0x22c55e, x: -8 },
                    { name: 'Up Proj', color: 0x3b82f6, x: 0 },
                    { name: 'Down Proj', color: 0xf97316, x: 8 }
                ];
                
                projections.forEach(proj => {
                    // Section label
                    expandedLayerGroup.add(createLabel(proj.name, new THREE.Vector3(proj.x, 8, 0), 0.6));
                    
                    // Box outline
                    const box = new THREE.Mesh(
                        new THREE.BoxGeometry(5, 10, 3),
                        new THREE.MeshBasicMaterial({ color: proj.color, wireframe: true, transparent: true, opacity: 0.3 })
                    );
                    box.position.set(proj.x, 0, 0);
                    expandedLayerGroup.add(box);
                    
                    // Neurons inside
                    const neuronCount = 150;
                    const geo = new THREE.BufferGeometry();
                    const pos = [];
                    const cols = [];
                    const baseC = new THREE.Color(proj.color);
                    
                    for (let i = 0; i < neuronCount; i++) {
                        pos.push(
                            proj.x + (Math.random() - 0.5) * 4.5,
                            (Math.random() - 0.5) * 9,
                            (Math.random() - 0.5) * 2.5
                        );
                        const bright = 0.5 + Math.random() * 0.5;
                        cols.push(baseC.r * bright, baseC.g * bright, baseC.b * bright);
                    }
                    
                    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                    geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
                    
                    const mat = new THREE.PointsMaterial({ size: 0.2, vertexColors: true });
                    expandedLayerGroup.add(new THREE.Points(geo, mat));
                });
                
                // Flow arrows between projections
                expandedLayerGroup.add(createLabel("‚Üí", new THREE.Vector3(-4, 0, 0), 1));
                expandedLayerGroup.add(createLabel("‚Üí", new THREE.Vector3(4, 0, 0), 1));
                
            } else if (type.includes('norm')) {
                // --- NORM: Scale and Shift parameters ---
                expandedLayerGroup.add(createLabel("üî¨ LAYERNORM EXTRACTION", new THREE.Vector3(0, 8, 0), 1));
                
                // Scale (gamma)
                expandedLayerGroup.add(createLabel("Scale (Œ≥)", new THREE.Vector3(-5, 5, 0), 0.6));
                const scaleGeo = new THREE.BufferGeometry();
                const scalePos = [];
                for (let i = 0; i < 100; i++) {
                    scalePos.push(-5 + (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 2);
                }
                scaleGeo.setAttribute('position', new THREE.Float32BufferAttribute(scalePos, 3));
                expandedLayerGroup.add(new THREE.Points(scaleGeo, new THREE.PointsMaterial({ color: 0xf97316, size: 0.25 })));
                
                // Shift (beta)
                expandedLayerGroup.add(createLabel("Shift (Œ≤)", new THREE.Vector3(5, 5, 0), 0.6));
                const shiftGeo = new THREE.BufferGeometry();
                const shiftPos = [];
                for (let i = 0; i < 100; i++) {
                    shiftPos.push(5 + (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 2);
                }
                shiftGeo.setAttribute('position', new THREE.Float32BufferAttribute(shiftPos, 3));
                expandedLayerGroup.add(new THREE.Points(shiftGeo, new THREE.PointsMaterial({ color: 0xfbbf24, size: 0.25 })));
                
            } else {
                // Generic layer
                expandedLayerGroup.add(createLabel("üî¨ WEIGHT MATRIX", new THREE.Vector3(0, 8, 0), 1));
                
                const neuronCount = 300;
                const geo = new THREE.BufferGeometry();
                const pos = [];
                for (let i = 0; i < neuronCount; i++) {
                    pos.push((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 5);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                expandedLayerGroup.add(new THREE.Points(geo, new THREE.PointsMaterial({ color: 0x06b6d4, size: 0.2 })));
            }
            
            scene.add(expandedLayerGroup);
            
            // Fly to a good viewing angle
            flyTo(new THREE.Vector3(0, 5, z + 25), new THREE.Vector3(0, 0, z));
            
            showToast("Features Extracted! Rotate to explore.");
        }
        
        function filterCompareLayersFromViz(name) {
             // Switch to compare tab and layout selection
             showTab('compare');
             // Small delay to allow render
             setTimeout(() => {
                 document.getElementById('layerSearch').value = name;
                 filterCompareLayers();
                 showLayerCompare(name);
             }, 100);
        }

        // --- PRE-PROCESSING: Generate Blank Analysis ---
        function generateBlankAnalysis(realAnalysis) {
             if (!realAnalysis) return null;
             const blank = JSON.parse(JSON.stringify(realAnalysis)); // Deep copy
             blank.layers.forEach(l => {
                 // Randomize Params to simulate initialized state
                 // Xavier/He initialization theory: mean=0, std=sqrt(2/fan_in) or similar.
                 // We will verify this visually. 
                 l.mean = (Math.random() - 0.5) * 0.001; 
                 l.std_dev = 0.02 + (Math.random() * 0.01); // Typical Init StdDev
                 l.min = -0.1;
                 l.max = 0.1;
             });
             return blank;
        }

        // --- Render Dashboard ---
        function updateVizSelector(models) {
             const select = document.getElementById('viz-model-select');
             const current = select.value;
             select.innerHTML = '<option value="">Select Model...</option>';
             
             Object.values(models)
                 .filter(m => m.analysis)
                 .sort((a,b) => a.name.localeCompare(b.name))
                 .forEach(m => {
                     // Ensure blank analysis exists locally if not from backend
                     if (!m.blank_analysis) {
                         m.blank_analysis = generateBlankAnalysis(m.analysis);
                     }
                 
                     const opt = document.createElement('option');
                     opt.value = m.name;
                     opt.innerText = m.name;
                     if(m.name === current) opt.selected = true;
                     select.appendChild(opt);
                 });
        }
        
        // --- Hyper-Visualizers (Increased Density & Detail) ---

        function renderHyperMLP(group, l, z, color, mName, isBlank) {
             const h = 12;
             const w = 8;
             const neuronCount = 400; // MUCH higher density of neurons
             const connectionCount = 5000; // 5000 lines per layer block
             
             // 1. Neuron Walls (Input & Output)
             // Use Points for performance, but make them bright
             const nodeGeo = new THREE.BufferGeometry();
             const nodePos = [];
             const nodeColors = [];
             const baseColor = new THREE.Color(color);
             const grayColor = new THREE.Color(0x888888);
             
             for(let i=0; i<neuronCount * 2; i++) {
                 // Spatially organized to look like a matrix
                 const x = (Math.random() - 0.5) * w;
                 const y = (Math.random() - 0.5) * h;
                 const isInput = i < neuronCount;
                 const zOffset = isInput ? -3 : 3;
                 
                 nodePos.push(x, y, z + zOffset);
                 
                 // Sim Value
                 const val = isBlank ? 0.01 : Math.random();
                 const c = isBlank ? grayColor : baseColor.clone().multiplyScalar(0.5 + val);
                 nodeColors.push(c.r, c.g, c.b);
             }
             
             nodeGeo.setAttribute('position', new THREE.Float32BufferAttribute(nodePos, 3));
             nodeGeo.setAttribute('color', new THREE.Float32BufferAttribute(nodeColors, 3));
             
             const nodeMat = new THREE.PointsMaterial({ size: 0.15, vertexColors: true, transparent: true, opacity: 0.9 });
             const nodes = new THREE.Points(nodeGeo, nodeMat);
             group.add(nodes);
             
             // 2. Dense Connections (The "Web")
             const lineGeo = new THREE.BufferGeometry();
             const linePos = [];
             const lineCols = [];
             
             for(let i=0; i<connectionCount; i++) {
                 // Pick random input and output
                 const inIdx = Math.floor(Math.random() * neuronCount);
                 const outIdx = Math.floor(Math.random() * neuronCount) + neuronCount;
                 
                 const ix = nodePos[inIdx*3];
                 const iy = nodePos[inIdx*3+1];
                 const iz = nodePos[inIdx*3+2];
                 
                 const ox = nodePos[outIdx*3];
                 const oy = nodePos[outIdx*3+1];
                 const oz = nodePos[outIdx*3+2];
                 
                 linePos.push(ix, iy, iz, ox, oy, oz);
                 
                 // Opacity/Brightness based on "Weight"
                 // Real: High variance. Blank: Low variance.
                 const weightStr = isBlank ? 0.05 : Math.pow(Math.random(), 3); // Power curve to show sparsity
                 const c = isBlank ? grayColor : baseColor;
                 lineCols.push(c.r*weightStr, c.g*weightStr, c.b*weightStr); // Vertex color fades black
                 lineCols.push(c.r*weightStr, c.g*weightStr, c.b*weightStr); 
             }
             lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
             lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(lineCols, 3));
             
             const lineMat = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: isBlank ? 0.1 : 0.4, blending: THREE.AdditiveBlending });
             const lines = new THREE.LineSegments(lineGeo, lineMat);
             group.add(lines);
             
             // 3. Inter-Layer Connector (Forward Pass Simulation)
             // Beam lines to next layer? (Visual only for now)
             
             // HitBox
             const hitBox = new THREE.Mesh(new THREE.BoxGeometry(w+2, h+2, 8), new THREE.MeshBasicMaterial({ visible: false }));
             hitBox.position.set(0, 0, z);
             // Calculated detailed stats for tooltip
             const simulatedParams = isBlank ? "Initialized (N(0, 0.02))" : `${(l.params/1000000).toFixed(2)}M`;
             hitBox.userData = { 
                 layerName: l.name, 
                 layerType: l.type, 
                 params: l.params, 
                 modelName: mName, 
                 stats: { 
                     mean: isBlank ? "~0.00" : l.mean.toExponential(2), 
                     std: isBlank ? "0.02" : l.std_dev.toFixed(4),
                     notes: isBlank ? "Random weights" : "Trained Pattern"
                 } 
             };
             interactableObjects.push(hitBox);
             group.add(hitBox);

             if(!isBlank) {
                 const lbl = createLabel(l.type.includes('gate') ? "MLP Gate" : "MLP Proj", new THREE.Vector3(0, h/2+1, z), 0.8);
                 group.add(lbl);
             }
        }

        function renderHyperAttention(group, l, z, color, mName, isBlank) {
             const numHeads = 12; // Visual representation
             const radius = 5;
             const attGroup = new THREE.Group();
             attGroup.position.set(0, 0, z);
             
             // Attn Heads - Distinct Blocks
             for(let i=0; i<numHeads; i++) {
                const angle = (i / numHeads) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                // Head Block
                const headGeo = new THREE.BoxGeometry(0.8, 0.8, 1.5);
                const headMat = new THREE.MeshStandardMaterial({ 
                    color: isBlank ? 0x555555 : color, 
                    emissive: isBlank ? 0x000000 : color,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0.9 
                });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.set(x, y, 0);
                attGroup.add(head);
                
                // Head Activity (Particles/Sparks)
                if (!isBlank) {
                    const sparkGeo = new THREE.BufferGeometry();
                    const sparkPos = [];
                    for(let k=0; k<10; k++) sparkPos.push((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5));
                    sparkGeo.setAttribute('position', new THREE.Float32BufferAttribute(sparkPos, 3));
                    const sparks = new THREE.Points(sparkGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.05}));
                    sparks.position.set(x,y,0);
                    attGroup.add(sparks);
                }

                // Dense Context Connections (The "Attention Pattern")
                const lineGeo = new THREE.BufferGeometry();
                const pos = [];
                const cols = [];
                const c = new THREE.Color(color);
                
                for(let k=0; k<50; k++) { 
                    // Lines converging to center "context"
                    // Real: Focused/Sparse. Blank: Uniform/Messy.
                    const targetX = (Math.random()-0.5) * (isBlank ? 4 : 1); // Real focuses tighter
                    const targetY = (Math.random()-0.5) * (isBlank ? 4 : 1);
                    
                    pos.push(x, y, 0, targetX, targetY, 0); 
                    
                    const intent = isBlank ? 0.1 : Math.random();
                    cols.push(c.r, c.g, c.b); // Start color
                    cols.push(1, 1, 1); // End white (center)
                }
                lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
                const lines = new THREE.LineSegments(lineGeo, new THREE.LineBasicMaterial({ vertexColors: true, opacity: isBlank ? 0.1 : 0.3, transparent: true, blending: THREE.AdditiveBlending }));
                attGroup.add(lines);
            }
             
            // Central Context Node
            const centerGeo = new THREE.SphereGeometry(1.5, 32, 32);
            const centerMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                roughness: 0.2,
                metalness: 0.8,
                transparent: true, 
                opacity: 0.6
            });
            const center = new THREE.Mesh(centerGeo, centerMat);
            attGroup.add(center);

            // HitBox
             const hitBox = new THREE.Mesh(new THREE.BoxGeometry(12, 12, 2), new THREE.MeshBasicMaterial({ visible: false }));
             hitBox.position.set(0, 0, z);
             // Attn Stats
             hitBox.userData = { layerName: l.name, layerType: "Self Attention", params: l.params, modelName: mName, stats: { mean: l.mean, std: l.std_dev, notes: isBlank ? "Uniform Attention" : "Learned Patterns" } };
             interactableObjects.push(hitBox);
             group.add(hitBox);

            group.add(attGroup);
            if(!isBlank) group.add(createLabel("Multi-Head Attn", new THREE.Vector3(0, 7, z), 0.8));
        }

        function renderTable(models) {
            const tbody = document.getElementById('modelTableBody');
            tbody.innerHTML = '';
            
            const list = Object.values(models).sort((a,b) => a.name.localeCompare(b.name));
            
            document.getElementById('totalModels').innerText = list.length;
            
            const selected = list.filter(m => m.selected).length;
            const loadable = list.filter(m => m.loadable).length;
            const benchmarked = list.filter(m => m.benchmarked).length;
            const verified = list.filter(m => m.checked).length;
            const analyzed = list.filter(m => m.analysis).length;
            
            document.getElementById('countSelected').innerText = selected;
            document.getElementById('countLoadable').innerText = loadable;
            document.getElementById('countBench').innerText = benchmarked;

            // Progress Logic
            if (currentTask === 'verify') {
                totalTaskCount = list.length;
                completedCount = verified;
                updateProgress();
            } else if (currentTask === 'benchmark') {
                totalTaskCount = loadable;
                completedCount = benchmarked;
                updateProgress();
            } else if (currentTask === 'analyze' || currentTask === 'compare') {
                totalTaskCount = selected;
                completedCount = analyzed;
                updateProgress();
            }

            list.forEach(m => {
                const tr = document.createElement('tr');
                tr.className = `hover:bg-gray-800/30 transition-colors group border-b border-gray-800/50 last:border-0 ${m.selected ? 'bg-cyan-900/10' : ''}`;
                tr.onclick = (e) => {
                    if (e.target.tagName !== 'INPUT') toggleSelect(m.name);
                };
                
                // Checkbox
                const checkCell = `
                    <div class="flex items-center justify-center">
                        <input type="checkbox" ${m.selected ? 'checked' : ''} 
                            class="w-4 h-4 rounded bg-gray-700 border-gray-600 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-gray-900 cursor-pointer"
                            onclick="event.stopPropagation(); toggleSelect('${m.name}')">
                    </div>
                `;

                // Status Icons
                let loadStatus = '<span class="text-gray-600">-</span>';
                if (m.checked) {
                    loadStatus = m.loadable 
                        ? '<span class="text-green-400 font-bold text-lg">‚úì</span>' 
                        : '<span class="text-red-500 font-bold text-lg">‚úï</span>';
                }

                // Bench Badge
                let tpsBadge = '<span class="text-gray-600 text-xs">-</span>';
                if (m.benchmarked && m.tps !== undefined && m.tps !== null) {
                    tpsBadge = `<span class="bg-cyan-500/10 text-cyan-400 px-2 py-1 rounded text-xs font-mono font-bold">${m.tps.toFixed(2)}</span>`;
                }

                // Status Text
                let statusText = '<span class="text-xs text-gray-600 font-mono">NEW</span>';
                if (m.error) statusText = `<span class="text-xs text-red-400 truncate w-32 block cursor-pointer hover:text-red-300" title="${m.error}" onclick="event.stopPropagation(); quickInspect('${m.name}')">üîç ERROR</span>`;
                else if (m.analysis) statusText = '<span class="text-xs text-cyan-400 font-medium">ANALYZED</span>';
                else if (m.benchmarked) statusText = '<span class="text-xs text-green-400 font-medium">COMPLETE</span>';
                else if (m.checked) statusText = '<span class="text-xs text-purple-400">CHECKED</span>';

                let output = m.example_output || '';
                let timeStr = '-';
                if (m.last_checked) {
                    const d = new Date(m.last_checked);
                    timeStr = d.toLocaleTimeString();
                }

                tr.innerHTML = `
                    <td class="px-4 py-4">${checkCell}</td>
                    <td class="px-6 py-4 cursor-pointer">
                        <div class="text-sm font-medium text-white">${m.name}</div>
                        ${m.hidden_size ? `<div class="text-xs text-gray-500">H: ${m.hidden_size} | V: ${m.vocab_size}</div>` : ''}
                    </td>
                    <td class="px-6 py-4 text-center">${loadStatus}</td>
                    <td class="px-6 py-4 text-center">${tpsBadge}</td>
                    <td class="px-6 py-4 text-center">${statusText}</td>
                    <td class="px-6 py-4">
                        <div class="text-xs text-gray-400 font-mono bg-black/30 p-2 rounded max-w-xs truncate group-hover:whitespace-normal group-hover:absolute group-hover:z-10 group-hover:bg-gray-900 group-hover:border group-hover:border-gray-700 group-hover:shadow-xl transition-all" title="${output}">
                            ${output || '<span class="opacity-30">Waiting...</span>'}
                        </div>
                    </td>
                    <td class="px-6 py-4 text-right text-xs text-gray-600 font-mono">${timeStr}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        // --- Render Analysis ---
        function renderAnalysis(models) {
            const container = document.getElementById('analysisGrid');
            const list = Object.values(models).filter(m => m.analysis).sort((a,b) => a.name.localeCompare(b.name));

            if (list.length === 0) {
                return; 
            }
            container.innerHTML = '';

            list.forEach(m => {
                const totalParams = (m.analysis.total_params / 1_000_000).toFixed(1);
                
                // Group layers by type for summary
                const typeCounts = {};
                m.analysis.layers.forEach(l => {
                    typeCounts[l.type] = (typeCounts[l.type] || 0) + 1;
                });
                
                const badges = Object.entries(typeCounts).map(([k,v]) => 
                    `<span class="bg-gray-800 text-gray-400 text-xs px-2 py-1 rounded border border-gray-700">${k}: ${v}</span>`
                ).join('');

                const card = document.createElement('div');
                card.className = 'glass rounded-xl p-6 border border-gray-700';
                
                const rows = m.analysis.layers.map(l => {
                    const p = (l.params / 1_000_000).toFixed(2);
                    return `
                        <tr class="border-b border-gray-800/50 hover:bg-white/5">
                            <td class="py-2 text-xs font-mono text-gray-400 truncate max-w-[200px]" title="${l.name}">${l.name}</td>
                            <td class="py-2 text-xs text-cyan-400">${l.type}</td>
                            <td class="py-2 text-xs text-right text-gray-300">${p}M</td>
                        </tr>
                    `;
                }).join('');

                card.innerHTML = `
                    <div class="flex justify-between items-start mb-4">
                        <div>
                            <h3 class="text-xl font-bold text-white">${m.name}</h3>
                            <div class="flex space-x-2 mt-2">${badges}</div>
                        </div>
                        <div class="text-right">
                            <span class="text-2xl font-bold text-cyan-400">${totalParams}M</span>
                            <span class="block text-xs text-gray-400 uppercase tracking-widest">Parameters</span>
                        </div>
                    </div>
                    
                    <div class="max-h-64 overflow-y-auto pr-2 no-scrollbar bg-black/20 rounded-lg p-4">
                        <table class="w-full text-left">
                            <thead class="text-xs uppercase text-gray-500 sticky top-0 bg-gray-900/90 backdrop-blur">
                                <tr>
                                    <th class="pb-2">Layer Name</th>
                                    <th class="pb-2">Type</th>
                                    <th class="pb-2 text-right">Params</th>
                                </tr>
                            </thead>
                            <tbody>${rows}</tbody>
                        </table>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        // --- Render Compare ---
        let selectedCompareLayer = null;

        function renderCompareView() {
            const list = Object.values(globalModels).filter(m => m.selected && m.analysis);
            document.getElementById('compareCount').innerText = list.length;
            
            // Collect all unique layers
            const layers = new Set();
            list.forEach(m => {
                if (m.analysis && m.analysis.layers) m.analysis.layers.forEach(l => layers.add(l.name));
            });
            
            const sortedLayers = Array.from(layers).sort(); 
            
            const listContainer = document.getElementById('compareLayerList');
            const currentSearch = document.getElementById('layerSearch').value.toLowerCase();
            
            listContainer.innerHTML = '';
            
            sortedLayers.forEach(name => {
                if (currentSearch && !name.toLowerCase().includes(currentSearch)) return;

                const btn = document.createElement('button');
                btn.className = `w-full text-left px-3 py-2 rounded text-xs font-mono transition-colors truncate ${selectedCompareLayer === name ? 'bg-cyan-900/30 text-cyan-400 border border-cyan-500/30' : 'text-gray-400 hover:bg-gray-800'}`;
                btn.innerText = name;
                btn.onclick = () => showLayerCompare(name);
                listContainer.appendChild(btn);
            });
            
            if (selectedCompareLayer && sortedLayers.includes(selectedCompareLayer)) {
                showLayerCompare(selectedCompareLayer);
            } else if (sortedLayers.length > 0 && !selectedCompareLayer) {
                // Optional: Auto select first
                // selectedCompareLayer = sortedLayers[0];
                // showLayerCompare(selectedCompareLayer);
            }
        }

        function filterCompareLayers() {
            renderCompareView();
        }

        function showLayerCompare(layerName) {
            selectedCompareLayer = layerName;
            document.getElementById('compareStatsEmpty').classList.add('hidden');
            document.getElementById('compareStatsContent').classList.remove('hidden');
            document.getElementById('compareLayerTitle').innerText = layerName;
            
            const tbody = document.getElementById('compareStatsBody');
            tbody.innerHTML = '';
            
            const list = Object.values(globalModels).filter(m => m.selected && m.analysis);
            
            list.forEach(m => {
                const layer = m.analysis.layers.find(l => l.name === layerName);
                if (!layer) return; 
                
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="py-3 pl-2 text-sm font-medium text-white">${m.name}</td>
                    <td class="py-3 text-right text-xs font-mono text-gray-300 font-bold">${layer.mean !== undefined ? layer.mean.toExponential(4) : '-'}</td>
                    <td class="py-3 text-right text-xs font-mono text-cyan-400 font-bold">${layer.std_dev !== undefined ? layer.std_dev.toFixed(6) : '-'}</td>
                    <td class="py-3 text-right text-xs font-mono text-gray-500">${layer.min !== undefined ? layer.min.toFixed(4) : '-'}</td>
                    <td class="py-3 text-right pr-2 text-xs font-mono text-gray-500">${layer.max !== undefined ? layer.max.toFixed(4) : '-'}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            document.getElementById('toastMsg').innerText = msg;
            toast.classList.remove('translate-y-24');
            setTimeout(() => toast.classList.add('translate-y-24'), 3000);
        }

        // --- Inspect Functions ---
        let currentInspectModel = null;

        function updateInspectModelSelector() {
            const select = document.getElementById('inspect-model-select');
            const current = select.value;
            select.innerHTML = '<option value="">Select a model to inspect...</option>';
            
            // Prioritize models with errors, then all others
            const errorModels = [];
            const okModels = [];
            
            Object.values(globalModels).forEach(m => {
                if (m.error) {
                    errorModels.push(m);
                } else {
                    okModels.push(m);
                }
            });
            
            // Sort each group by name
            errorModels.sort((a, b) => a.name.localeCompare(b.name));
            okModels.sort((a, b) => a.name.localeCompare(b.name));
            
            // Add error models first with ‚ùå prefix
            if (errorModels.length > 0) {
                const optGroup = document.createElement('optgroup');
                optGroup.label = '‚ùå Failed Models';
                errorModels.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.name;
                    opt.innerText = m.name;
                    if (m.name === current) opt.selected = true;
                    optGroup.appendChild(opt);
                });
                select.appendChild(optGroup);
            }
            
            // Add OK models
            if (okModels.length > 0) {
                const optGroup = document.createElement('optgroup');
                optGroup.label = '‚úì Other Models';
                okModels.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.name;
                    opt.innerText = m.name;
                    if (m.name === current) opt.selected = true;
                    optGroup.appendChild(opt);
                });
                select.appendChild(optGroup);
            }
        }
        
        function onInspectModelChange() {
            currentInspectModel = document.getElementById('inspect-model-select').value;
        }
        
        function runInspection() {
            const modelName = document.getElementById('inspect-model-select').value;
            if (!modelName) {
                showToast('Please select a model first');
                return;
            }
            
            showToast(`Inspecting ${modelName}...`);
            
            // Show loading state
            const container = document.getElementById('inspect-results');
            container.innerHTML = `
                <div class="flex items-center justify-center py-20">
                    <div class="w-8 h-8 border-4 border-amber-500 border-t-transparent rounded-full animate-spin mr-4"></div>
                    <span class="text-amber-400 font-mono">Analyzing model structure...</span>
                </div>
            `;
            
            sendAction('inspect', { name: modelName });
        }
        
        function renderInspectResult(data) {
            const container = document.getElementById('inspect-results');
            
            if (!data) {
                container.innerHTML = '<div class="text-center py-20 text-red-400">Failed to load inspection data</div>';
                return;
            }
            
            const summary = data.summary || {};
            const config = data.config || {};
            const tensors = data.tensors || [];
            
            let html = '';
            
            // Header with model name
            html += `
                <div class="glass rounded-xl p-6 border border-gray-700">
                    <h3 class="text-xl font-bold text-white mb-2 font-mono">${data.model_name}</h3>
                    <p class="text-xs text-gray-500 font-mono break-all">${data.model_path || 'Unknown path'}</p>
                </div>
            `;
            
            // Error Alert (if any)
            if (data.error) {
                html += `
                    <div class="bg-red-900/30 border border-red-500/50 rounded-xl p-6">
                        <div class="flex items-start space-x-4">
                            <div class="text-3xl">‚ùå</div>
                            <div>
                                <h4 class="text-lg font-bold text-red-400 mb-2">Load Error</h4>
                                <p class="text-red-300 font-mono text-sm break-all">${data.error}</p>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Summary Cards
            html += `
                <div class="grid grid-cols-2 md:grid-cols-6 gap-4">
                    <div class="glass rounded-lg p-4 text-center border ${summary.has_config ? 'border-green-500/30' : 'border-red-500/30'}">
                        <div class="text-2xl mb-1">${summary.has_config ? '‚úì' : '‚úï'}</div>
                        <div class="text-xs text-gray-400">config.json</div>
                    </div>
                    <div class="glass rounded-lg p-4 text-center border ${summary.has_safetensors ? 'border-green-500/30' : 'border-red-500/30'}">
                        <div class="text-2xl mb-1">${summary.has_safetensors ? '‚úì' : '‚úï'}</div>
                        <div class="text-xs text-gray-400">model.safetensors</div>
                    </div>
                    <div class="glass rounded-lg p-4 text-center border ${summary.has_tokenizer ? 'border-green-500/30' : 'border-yellow-500/30'}">
                        <div class="text-2xl mb-1">${summary.has_tokenizer ? '‚úì' : '‚ö†Ô∏è'}</div>
                        <div class="text-xs text-gray-400">tokenizer.json</div>
                    </div>
                    <div class="glass rounded-lg p-4 text-center border border-gray-700">
                        <div class="text-2xl font-bold text-white mb-1">${summary.total_tensors || 0}</div>
                        <div class="text-xs text-gray-400">Total Tensors</div>
                    </div>
                    <div class="glass rounded-lg p-4 text-center border border-green-500/30">
                        <div class="text-2xl font-bold text-green-400 mb-1">${summary.recognized_tensors || 0}</div>
                        <div class="text-xs text-gray-400">Recognized</div>
                    </div>
                    <div class="glass rounded-lg p-4 text-center border ${summary.unknown_tensors > 0 ? 'border-amber-500/30' : 'border-gray-700'}">
                        <div class="text-2xl font-bold ${summary.unknown_tensors > 0 ? 'text-amber-400' : 'text-gray-500'} mb-1">${summary.unknown_tensors || 0}</div>
                        <div class="text-xs text-gray-400">Unknown</div>
                    </div>
                </div>
            `;
            
            // Config Panel
            if (Object.keys(config).length > 0) {
                const importantKeys = ['architectures', 'hidden_size', 'num_hidden_layers', 'num_attention_heads', 'intermediate_size', 'vocab_size', 'model_type'];
                html += `
                    <div class="glass rounded-xl p-6 border border-gray-700">
                        <h4 class="text-lg font-bold text-white mb-4">üìã Configuration</h4>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                `;
                
                importantKeys.forEach(key => {
                    if (config[key] !== undefined) {
                        let val = config[key];
                        if (Array.isArray(val)) val = val.join(', ');
                        html += `
                            <div class="bg-gray-900/50 rounded-lg p-3">
                                <div class="text-xs text-gray-500 mb-1">${key}</div>
                                <div class="text-sm font-mono text-cyan-400 truncate" title="${val}">${val}</div>
                            </div>
                        `;
                    }
                });
                
                html += `</div></div>`;
            }
            
            // Tensor Table
            if (tensors.length > 0) {
                html += `
                    <div class="glass rounded-xl border border-gray-700 overflow-hidden">
                        <div class="p-4 border-b border-gray-700 bg-gray-900/50">
                            <h4 class="text-lg font-bold text-white">üß© Tensor Analysis</h4>
                            <p class="text-xs text-gray-500 mt-1">Green = Recognized by LOOM, Amber = Unknown pattern</p>
                        </div>
                        <div class="overflow-x-auto max-h-96 overflow-y-auto">
                            <table class="w-full text-left text-sm">
                                <thead class="bg-gray-800/50 text-xs uppercase text-gray-400 sticky top-0">
                                    <tr>
                                        <th class="px-4 py-3">Status</th>
                                        <th class="px-4 py-3">Tensor Name</th>
                                        <th class="px-4 py-3">Layer Type</th>
                                        <th class="px-4 py-3">Matched Pattern</th>
                                    </tr>
                                </thead>
                                <tbody class="divide-y divide-gray-800">
                `;
                
                tensors.forEach(t => {
                    const statusIcon = t.recognized ? '‚úÖ' : '‚ö†Ô∏è';
                    const rowClass = t.recognized ? '' : 'bg-amber-900/10';
                    const typeClass = t.recognized ? 'text-green-400' : 'text-amber-400';
                    
                    html += `
                        <tr class="${rowClass}">
                            <td class="px-4 py-2 text-center">${statusIcon}</td>
                            <td class="px-4 py-2 font-mono text-xs text-gray-300 break-all">${t.name}</td>
                            <td class="px-4 py-2 font-mono text-xs ${typeClass}">${t.layer_type}</td>
                            <td class="px-4 py-2 font-mono text-xs text-gray-500">${t.pattern || '-'}</td>
                        </tr>
                    `;
                });
                
                html += `</tbody></table></div></div>`;
            }
            
            container.innerHTML = html;
        }
        
        // Quick inspect from dashboard (for error models)
        function quickInspect(modelName) {
            showTab('inspect');
            document.getElementById('inspect-model-select').value = modelName;
            currentInspectModel = modelName;
            runInspection();
        }

        // Start connection
        connect();
        
        // Default tab
        showTab('dashboard');
    </script>
</body>
</html>
